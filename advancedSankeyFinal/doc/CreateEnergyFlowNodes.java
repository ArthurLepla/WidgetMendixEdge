// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., √©, √∂, √†, etc. are supported in comments.

package smart.actions;

import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.stream.Collectors;
import com.mendix.core.Core;
import smart.proxies.Asset;
import smart.proxies.Level;
import smart.proxies.Variable;
import smart.proxies.EnergyFlowNode;
import smart.proxies.EnergyType;
import smart.proxies.MetricType;
import com.mendix.systemwideinterfaces.core.UserAction;

public class CreateEnergyFlowNodes extends CustomJavaAction<java.lang.Void>
{
	private final smart.proxies.EnergyType EnergyType;
	private final smart.proxies.MetricType MetricType;

	public CreateEnergyFlowNodes(
		IContext context,
		java.lang.String _energyType,
		java.lang.String _metricType
	)
	{
		super(context);
		this.EnergyType = _energyType == null ? null : smart.proxies.EnergyType.valueOf(_energyType);
		this.MetricType = _metricType == null ? null : smart.proxies.MetricType.valueOf(_metricType);
	}

	@java.lang.Override
	public java.lang.Void executeAction() throws Exception
	{
		// BEGIN USER CODE
		IContext context = getContext();
		List<IMendixObject> energyFlowNodes = new ArrayList<>();
		
		Core.getLogger("CreateEnergyFlowNodes").info(
			"üöÄ Starting CreateEnergyFlowNodes - EnergyType: " + EnergyType + ", MetricType: " + MetricType);
		
		// Clean existing EnergyFlowNode
		List<IMendixObject> existingFlowNodes = Core.retrieveXPathQuery(context, "//Smart.EnergyFlowNode");
		if (!existingFlowNodes.isEmpty()) {
			Core.delete(context, existingFlowNodes);
			Core.getLogger("CreateEnergyFlowNodes").info("üóëÔ∏è Deleted " + existingFlowNodes.size() + " existing EnergyFlowNodes");
		}
		
		// Clean existing virtual root assets
		List<IMendixObject> virtualRoots = Core.retrieveXPathQuery(context, "//Smart.Asset[Nom = 'ALIMENTATION PRINCIPALE']");
		if (!virtualRoots.isEmpty()) {
			Core.delete(context, virtualRoots);
			Core.getLogger("CreateEnergyFlowNodes").info("üóëÔ∏è Deleted " + virtualRoots.size() + " existing virtual root assets");
		}
		
		// 1. R√©cup√©rer TOUS les assets
		List<Asset> allAssets = Asset.load(context, "");
		Core.getLogger("CreateEnergyFlowNodes").info("üì¶ Found " + allAssets.size() + " assets");
		
		// 2. R√©cup√©rer TOUS les levels
		List<Level> allLevels = Level.load(context, "");
		Map<Long, Level> levelMap = allLevels.stream()
			.collect(Collectors.toMap(level -> level.getMendixObject().getId().toLong(), level -> level));
		Core.getLogger("CreateEnergyFlowNodes").info("üìä Found " + allLevels.size() + " levels");
		
		// 3. R√©cup√©rer TOUTES les variables (pour validation si n√©cessaire)
		List<Variable> allVariables = Variable.load(context, "");
		Core.getLogger("CreateEnergyFlowNodes").info("üîß Found " + allVariables.size() + " variables");
		
		// 4. Organiser les assets par level
		Map<Long, List<Asset>> assetsByLevel = organizeAssetsByLevel(allAssets, levelMap);
		
		// 5. Cr√©er les flux entre niveaux cons√©cutifs + n≈ìud racine virtuel
		energyFlowNodes = createAllFlows(context, assetsByLevel, levelMap);
		
		// 6. Commit
		if (!energyFlowNodes.isEmpty()) {
			Core.commitWithoutEvents(context, energyFlowNodes);
			Core.getLogger("CreateEnergyFlowNodes").info(
				"‚úÖ Successfully created " + energyFlowNodes.size() + " EnergyFlowNodes");
		}
		
		return null;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "CreateEnergyFlowNodes";
	}

	// BEGIN EXTRA CODE
	
	/**
	 * Organise tous les assets par level
	 */
	private Map<Long, List<Asset>> organizeAssetsByLevel(List<Asset> allAssets, Map<Long, Level> levelMap) throws Exception {
		Map<Long, List<Asset>> assetsByLevel = new HashMap<>();
		
		for (Asset asset : allAssets) {
			try {
				Level level = asset.getAsset_Level(getContext());
				if (level != null) {
					Long levelId = level.getMendixObject().getId().toLong();
					assetsByLevel.computeIfAbsent(levelId, k -> new ArrayList<>()).add(asset);
				}
			} catch (Exception e) {
				Core.getLogger("CreateEnergyFlowNodes").warn("Error getting level for asset " + asset.getNom() + ": " + e.getMessage());
			}
		}
		
		// Log des r√©sultats
		for (Map.Entry<Long, List<Asset>> entry : assetsByLevel.entrySet()) {
			Level level = levelMap.get(entry.getKey());
			String levelName = level != null ? level.getName() : "Unknown";
			Core.getLogger("CreateEnergyFlowNodes").info(
				"üìã Level '" + levelName + "': " + entry.getValue().size() + " assets");
		}
		
		return assetsByLevel;
	}
	
	/**
	 * Cr√©er tous les flux entre niveaux cons√©cutifs + n≈ìud racine virtuel
	 */
	private List<IMendixObject> createAllFlows(IContext context, Map<Long, List<Asset>> assetsByLevel, Map<Long, Level> levelMap) throws Exception {
		List<IMendixObject> allFlowNodes = new ArrayList<>();
		
		// Trier les levels par ordre
		List<Level> sortedLevels = levelMap.values().stream()
			.filter(level -> level.getSortOrder() != null)
			.sorted((l1, l2) -> Integer.compare(l1.getSortOrder(), l2.getSortOrder()))
			.collect(Collectors.toList());
		
		// üÜï NOUVEAU : Cr√©er un n≈ìud racine virtuel si n√©cessaire
		if (!sortedLevels.isEmpty()) {
			Level firstLevel = sortedLevels.get(0);
			List<Asset> firstLevelAssets = assetsByLevel.get(firstLevel.getMendixObject().getId().toLong());
			
			if (firstLevelAssets != null && !firstLevelAssets.isEmpty()) {
				Core.getLogger("CreateEnergyFlowNodes").info("üå± Creating virtual root node flows");
				List<IMendixObject> rootFlows = createVirtualRootFlows(context, firstLevelAssets);
				allFlowNodes.addAll(rootFlows);
			}
		}
		
		// Cr√©er des flux entre chaque niveau cons√©cutif (logique existante)
		for (int i = 0; i < sortedLevels.size() - 1; i++) {
			Level currentLevel = sortedLevels.get(i);
			Level nextLevel = sortedLevels.get(i + 1);
			
			Long currentLevelId = currentLevel.getMendixObject().getId().toLong();
			Long nextLevelId = nextLevel.getMendixObject().getId().toLong();
			
			List<Asset> currentAssets = assetsByLevel.get(currentLevelId);
			List<Asset> nextAssets = assetsByLevel.get(nextLevelId);
			
			if (currentAssets != null && nextAssets != null && !currentAssets.isEmpty() && !nextAssets.isEmpty()) {
				Core.getLogger("CreateEnergyFlowNodes").info(
					"üîó Creating flows from " + currentLevel.getName() + " to " + nextLevel.getName());
				
				List<IMendixObject> levelFlows = createFlowsBetweenLevels(context, currentAssets, nextAssets);
				allFlowNodes.addAll(levelFlows);
			}
		}
		
		return allFlowNodes;
	}
	
	/**
	 * üÜï NOUVELLE M√âTHODE : Cr√©er les flux depuis un n≈ìud racine virtuel
	 */
	private List<IMendixObject> createVirtualRootFlows(IContext context, List<Asset> firstLevelAssets) throws Exception {
		List<IMendixObject> flowNodes = new ArrayList<>();
		
		// Calculer la valeur totale de tous les assets du premier niveau
		java.math.BigDecimal totalValue = calculateTotalValue(firstLevelAssets);
		
		Core.getLogger("CreateEnergyFlowNodes").info("üå± Virtual root total value: " + totalValue);
		
		// Cr√©er un flux depuis le root virtuel vers chaque asset du premier niveau
		for (Asset firstLevelAsset : firstLevelAssets) {
			java.math.BigDecimal assetValue = getAssetValue(firstLevelAsset);
			java.math.BigDecimal percentage = calculatePercentage(assetValue, totalValue);
			
			EnergyFlowNode flowNode = new EnergyFlowNode(context);
			// Repr√©sente le ROOT par une source nulle (pas d'Asset virtuel persistant)
			flowNode.setSourceAsset((Asset) null);
			flowNode.setTargetAsset(firstLevelAsset);
			flowNode.setFlowValue(assetValue);
			flowNode.setPercentage(percentage);
			
			flowNodes.add(flowNode.getMendixObject());
			
			Core.getLogger("CreateEnergyFlowNodes").info(
				"‚úÖ Root Flow: ROOT ‚Üí " + firstLevelAsset.getNom() + 
				" (Value: " + assetValue + ", %: " + percentage + ")");
		}
		
		return flowNodes;
	}
	
	/**
	 * üÜï NOUVELLE M√âTHODE : Cr√©er un asset virtuel pour le root
	 */
	private Asset createVirtualRootAsset(IContext context) throws Exception {
		Asset virtualRoot = new Asset(context);
		virtualRoot.setNom("ALIMENTATION PRINCIPALE"); // Nom parlant pour l'utilisateur
		
		// D√©finir des valeurs par d√©faut pour √©viter les erreurs
		virtualRoot.setConsoTotalElec(java.math.BigDecimal.ZERO);
		virtualRoot.setConsoTotalGaz(java.math.BigDecimal.ZERO);
		virtualRoot.setConsoTotalEau(java.math.BigDecimal.ZERO);
		virtualRoot.setConsoTotalAir(java.math.BigDecimal.ZERO);
		
		// Sauvegarder l'asset virtuel pour pouvoir le r√©f√©rencer
		Core.commit(context, virtualRoot.getMendixObject());
		
		return virtualRoot;
	}
	
	/**
	 * üÜï NOUVELLE M√âTHODE : Calculer la valeur totale d'une liste d'assets
	 */
	private java.math.BigDecimal calculateTotalValue(List<Asset> assets) {
		java.math.BigDecimal total = java.math.BigDecimal.ZERO;
		for (Asset asset : assets) {
			java.math.BigDecimal value = getAssetValue(asset);
			if (value != null) {
				total = total.add(value);
			}
		}
		return total;
	}
	
	/**
	 * Cr√©er des flux entre deux niveaux
	 */
	private List<IMendixObject> createFlowsBetweenLevels(IContext context, List<Asset> sourceAssets, List<Asset> targetAssets) throws Exception {
		List<IMendixObject> flowNodes = new ArrayList<>();
		
		Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG createFlowsBetweenLevels - Source assets: " + sourceAssets.size() + ", Target assets: " + targetAssets.size());
		
		for (Asset sourceAsset : sourceAssets) {
			Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG createFlowsBetweenLevels - Processing source asset: " + sourceAsset.getNom());
			
			// Trouver les enfants directs dans le niveau suivant
			List<Asset> children = targetAssets.stream()
				.filter(target -> isDirectChild(context, target, sourceAsset))
				.collect(Collectors.toList());
			
			Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG createFlowsBetweenLevels - Found " + children.size() + " children for " + sourceAsset.getNom());
			
			if (children.isEmpty()) {
				Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG createFlowsBetweenLevels - No children found for " + sourceAsset.getNom() + ", skipping");
				continue; // Pas d'enfants directs
			}
			
			// Valeur du parent pour calculer les pourcentages
			java.math.BigDecimal sourceValue = getAssetValue(sourceAsset);
			Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG createFlowsBetweenLevels - Source value for " + sourceAsset.getNom() + ": " + sourceValue);
			
			// Cr√©er un flux vers chaque enfant
			for (Asset child : children) {
				java.math.BigDecimal childValue = getAssetValue(child);
				java.math.BigDecimal percentage = calculatePercentage(childValue, sourceValue);
				
				Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG createFlowsBetweenLevels - Creating flow: " + sourceAsset.getNom() + " ‚Üí " + child.getNom() + " (Child value: " + childValue + ", %: " + percentage + ")");
				
				EnergyFlowNode flowNode = new EnergyFlowNode(context);
				flowNode.setSourceAsset(sourceAsset);
				flowNode.setTargetAsset(child);
				flowNode.setFlowValue(childValue);
				flowNode.setPercentage(percentage);
				
				flowNodes.add(flowNode.getMendixObject());
				
				Core.getLogger("CreateEnergyFlowNodes").info(
					"‚úÖ Flow: " + sourceAsset.getNom() + " ‚Üí " + child.getNom() + 
					" (Value: " + childValue + ", %: " + percentage + ")");
			}
		}
		
		Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG createFlowsBetweenLevels - Total flows created: " + flowNodes.size());
		return flowNodes;
	}
	
	/**
	 * V√©rifier si target est un enfant direct de source
	 */
	private boolean isDirectChild(IContext context, Asset target, Asset source) {
		try {
			Asset parent = target.getAsset_Parent(context);
			boolean isChild = parent != null && parent.getMendixObject().getId().equals(source.getMendixObject().getId());
			
			if (isChild) {
				Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG isDirectChild - ‚úÖ " + target.getNom() + " is child of " + source.getNom());
			} else {
				Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG isDirectChild - ‚ùå " + target.getNom() + " is NOT child of " + source.getNom() + " (parent: " + (parent != null ? parent.getNom() : "null") + ")");
			}
			
			return isChild;
		} catch (Exception e) {
			Core.getLogger("CreateEnergyFlowNodes").error("‚ùå Error in isDirectChild for " + target.getNom() + " ‚Üí " + source.getNom() + ": " + e.getMessage());
			return false;
		}
	}
	
	/**
	 * R√©cup√©rer la valeur de l'asset selon EnergyType et MetricType
	 */
	private java.math.BigDecimal getAssetValue(Asset asset) {
		try {
			if (EnergyType == null || MetricType == null) {
				Core.getLogger("CreateEnergyFlowNodes").warn("üîç DEBUG getAssetValue - EnergyType or MetricType is null: EnergyType=" + EnergyType + ", MetricType=" + MetricType);
				return java.math.BigDecimal.ZERO;
			}
			
			Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - Asset: " + asset.getNom() + ", EnergyType: " + EnergyType + ", MetricType: " + MetricType);
			
			java.math.BigDecimal value = java.math.BigDecimal.ZERO;
			
			// Utiliser directement les enums pour un mapping plus s√ªr
			if (MetricType == smart.proxies.MetricType.Conso) {
				switch (EnergyType) {
					case Elec:
						value = asset.getConsoTotalElec();
						Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - Conso Elec case, value: " + value);
						break;
					case Gaz:
						value = asset.getConsoTotalGaz();
						Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - Conso Gaz case, value: " + value);
						break;
					case Eau:
						value = asset.getConsoTotalEau();
						Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - Conso Eau case, value: " + value);
						break;
					case Air:
						value = asset.getConsoTotalAir();
						Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - Conso Air case, value: " + value);
						break;
					default:
						Core.getLogger("CreateEnergyFlowNodes").warn("‚ö†Ô∏è No mapping for Conso + " + EnergyType + " (Asset: " + asset.getNom() + ")");
						break;
				}
			} else if (MetricType == smart.proxies.MetricType.IPE) {
				switch (EnergyType) {
					case Elec:
						value = asset.getIPEElec();
						Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - IPE Elec case, value: " + value);
						break;
					case Gaz:
						value = asset.getIPEGaz();
						Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - IPE Gaz case, value: " + value);
						break;
					case Eau:
						value = asset.getIPEEau();
						Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - IPE Eau case, value: " + value);
						break;
					case Air:
						value = asset.getIPEAir();
						Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - IPE Air case, value: " + value);
						break;
					default:
						Core.getLogger("CreateEnergyFlowNodes").warn("‚ö†Ô∏è No mapping for IPE + " + EnergyType + " (Asset: " + asset.getNom() + ")");
						break;
				}
			} else if (MetricType == smart.proxies.MetricType.IPE_kg) {
				switch (EnergyType) {
					case Elec:
						value = asset.getIPEElecKg();
						Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - IPE_kg Elec case, value: " + value);
						break;
					case Gaz:
						value = asset.getIPEGazKg();
						Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - IPE_kg Gaz case, value: " + value);
						break;
					case Eau:
						value = asset.getIPEEauKg();
						Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - IPE_kg Eau case, value: " + value);
						break;
					case Air:
						value = asset.getIPEAirKg();
						Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - IPE_kg Air case, value: " + value);
						break;
					default:
						Core.getLogger("CreateEnergyFlowNodes").warn("‚ö†Ô∏è No mapping for IPE_kg + " + EnergyType + " (Asset: " + asset.getNom() + ")");
						break;
				}
			} else if (MetricType == smart.proxies.MetricType.Prod) {
				// Production n'a pas de type d'√©nergie sp√©cifique (EnergyType.None)
				value = asset.getProdTotal();
				Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - Prod case, value: " + value);
			} else if (MetricType == smart.proxies.MetricType.Prod_kg) {
				// Production kg n'a pas de type d'√©nergie sp√©cifique (EnergyType.None)
				value = asset.getProdTotalKg();
				Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - Prod_kg case, value: " + value);
			} else {
				Core.getLogger("CreateEnergyFlowNodes").warn("‚ö†Ô∏è No mapping for MetricType: " + MetricType + " + EnergyType: " + EnergyType + " (Asset: " + asset.getNom() + ")");
			}
			
			java.math.BigDecimal finalValue = value != null ? value : java.math.BigDecimal.ZERO;
			Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG getAssetValue - Final value for " + asset.getNom() + ": " + finalValue);
			return finalValue;
			
		} catch (Exception e) {
			Core.getLogger("CreateEnergyFlowNodes").error("‚ùå Error getting value for " + asset.getNom() + ": " + e.getMessage());
			return java.math.BigDecimal.ZERO;
		}
	}
	
	/**
	 * Calculer le pourcentage
	 */
	private java.math.BigDecimal calculatePercentage(java.math.BigDecimal value, java.math.BigDecimal total) {
		if (total.compareTo(java.math.BigDecimal.ZERO) == 0) {
			// Si la valeur source est 0, tous les enfants auront 0%
			// Cela est plus logique que d'attribuer 100% √† chaque enfant
			Core.getLogger("CreateEnergyFlowNodes").info("üîç DEBUG calculatePercentage - Total is 0, using 0% for logical consistency");
			return java.math.BigDecimal.ZERO;
		}
		return value.multiply(new java.math.BigDecimal("100"))
			.divide(total, 2, java.math.RoundingMode.HALF_UP);
	}
	
	// END EXTRA CODE
}
