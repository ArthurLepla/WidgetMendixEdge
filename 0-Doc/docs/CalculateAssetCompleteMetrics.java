// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., √©, √∂, √†, etc. are supported in comments.

package smart.actions;

import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.stream.Collectors;
import com.mendix.core.Core;
import smart.proxies.Asset;
import smart.proxies.Variable;
import smart.proxies.TimeSeriesPoint;
import smart.proxies.MetricType;
import iihessentialsconnector.proxies.CalculateRequest;
import iihessentialsconnector.proxies.DataSources;
import iihessentialsconnector.proxies.DataSource;
import iihessentialsconnector.proxies.ENUM_Calculate_Type;
import iihessentialsconnector.proxies.CalculateMessage;
import iihessentialsconnector.proxies.Calculation;
import iihessentialsconnector.proxies.CalculationValue;
import iihessentialsconnector.proxies.HttpError;
import com.mendix.systemwideinterfaces.core.UserAction;

public class CalculateAssetCompleteMetrics extends CustomJavaAction<java.util.List<IMendixObject>>
{
	/** @deprecated use DateRange.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __DateRange;
	private final smart.proxies.DateRange DateRange;
	/** @deprecated use SelectedAsset.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __SelectedAsset;
	private final smart.proxies.SelectedAsset SelectedAsset;
	private final smart.proxies.EnergyType EnergyType;
	private final java.lang.Boolean IncludeIPE;
	private final java.lang.Boolean IncludeProduction;
	/** @deprecated use CalculationTrend.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __CalculationTrend;
	private final smart.proxies.CalculationTrend CalculationTrend;

	public CalculateAssetCompleteMetrics(
		IContext context,
		IMendixObject _dateRange,
		IMendixObject _selectedAsset,
		java.lang.String _energyType,
		java.lang.Boolean _includeIPE,
		java.lang.Boolean _includeProduction,
		IMendixObject _calculationTrend
	)
	{
		super(context);
		this.__DateRange = _dateRange;
		this.DateRange = _dateRange == null ? null : smart.proxies.DateRange.initialize(getContext(), _dateRange);
		this.__SelectedAsset = _selectedAsset;
		this.SelectedAsset = _selectedAsset == null ? null : smart.proxies.SelectedAsset.initialize(getContext(), _selectedAsset);
		this.EnergyType = _energyType == null ? null : smart.proxies.EnergyType.valueOf(_energyType);
		this.IncludeIPE = _includeIPE;
		this.IncludeProduction = _includeProduction;
		this.__CalculationTrend = _calculationTrend;
		this.CalculationTrend = _calculationTrend == null ? null : smart.proxies.CalculationTrend.initialize(getContext(), _calculationTrend);
	}

	@java.lang.Override
	public java.util.List<IMendixObject> executeAction() throws Exception
	{
		// BEGIN USER CODE
		IContext context = getContext();
		
		// Validation des param√®tres d'entr√©e
		if (SelectedAsset == null || SelectedAsset.getSelectedAssetName() == null) {
			throw new Exception("SelectedAsset ou SelectedAssetName manquant");
		}
		if (DateRange == null) {
			throw new Exception("DateRange manquant");
		}
		if (CalculationTrend == null) {
			throw new Exception("CalculationTrend manquant");
		}
		if (EnergyType == null) {
			throw new Exception("EnergyType manquant");
		}
		
		// Parse asset names from SelectedAsset
		String[] assetNames = SelectedAsset.getSelectedAssetName().split(",");
		
		// Clean ALL existing TimeSeriesPoint to avoid duplication (same as CalculateSingleMetric)
		List<IMendixObject> existingPoints = Core.retrieveXPathQuery(context, "//Smart.TimeSeriesPoint");
		Core.delete(context, existingPoints);
		
		List<IMendixObject> allTimeSeriesPoints = new ArrayList<>();
		Asset primaryAsset = null;
		
		// Structure pour accumuler les totaux par Asset
		Map<Long, AssetTotals> assetTotalsMap = new HashMap<>();
		
		// Process each asset
		for (String assetName : assetNames) {
			List<Asset> assets = Asset.load(context, "[Nom = '" + assetName.trim() + "']");
			if (assets.isEmpty()) {
				Core.getLogger("CalculateAssetCompleteMetrics").warn("Asset not found: " + assetName);
				continue;
			}
			
			Asset asset = assets.get(0);
			if (primaryAsset == null) {
				primaryAsset = asset; // First asset will be returned
			}
			
			// Get all variables for this asset
			List<Variable> variableList = Variable.load(context, 
				"[Smart.Variable_Asset = " + asset.getMendixObject().getId().toLong() + "]");
			
			// Build list of metrics to calculate
			List<MetricType> metricsToCalculate = new ArrayList<>();
			
			// Always include consumption for the specified energy type
			metricsToCalculate.add(MetricType.Conso);
			
			// Add IPE if requested
			if (IncludeIPE != null && IncludeIPE) {
				metricsToCalculate.add(MetricType.IPE);
				
				// Only add IPE_kg if variables exist for this type
				List<Variable> ipeKgVars = variableList.stream()
					.filter(v -> v.getMetricType() != null && v.getMetricType() == MetricType.IPE_kg)
					.filter(v -> v.getEnergyType() != null && v.getEnergyType() == EnergyType)
					.collect(Collectors.toList());
				if (!ipeKgVars.isEmpty()) {
					metricsToCalculate.add(MetricType.IPE_kg);
				}
			}
			
			// Add Production if requested
			if (IncludeProduction != null && IncludeProduction) {
				Core.getLogger("CalculateAssetCompleteMetrics").info(
					"üè≠ [Asset: " + assetName + "] Production requested, adding Prod metric");
				metricsToCalculate.add(MetricType.Prod);
				
				// Only add Prod_kg if variables exist for this type
				// Pour Production, chercher EnergyType = None, pas EnergyType demand√©
				List<Variable> prodKgVars = variableList.stream()
					.filter(v -> v.getMetricType() != null && v.getMetricType() == MetricType.Prod_kg)
					.filter(v -> v.getEnergyType() != null && v.getEnergyType() == smart.proxies.EnergyType.None)
					.collect(Collectors.toList());
				if (!prodKgVars.isEmpty()) {
					Core.getLogger("CalculateAssetCompleteMetrics").info(
						"üè≠ [Asset: " + assetName + "] Found " + prodKgVars.size() + " Prod_kg variables, adding Prod_kg metric");
					metricsToCalculate.add(MetricType.Prod_kg);
				} else {
					Core.getLogger("CalculateAssetCompleteMetrics").warn(
						"‚ö†Ô∏è [Asset: " + assetName + "] No Prod_kg variables found with EnergyType = None");
				}
			} else {
				Core.getLogger("CalculateAssetCompleteMetrics").info(
					"üè≠ [Asset: " + assetName + "] Production not requested (IncludeProduction = " + IncludeProduction + ")");
			}
			
			// Initialiser les totaux pour cet asset
			Long assetId = asset.getMendixObject().getId().toLong();
			AssetTotals totals = assetTotalsMap.computeIfAbsent(assetId, k -> new AssetTotals(asset));
			
			// Calculate each metric
			for (MetricType metricType : metricsToCalculate) {
				// Find matching variable with flexible EnergyType for Production metrics
				Variable matchingVariable = variableList.stream()
					.filter(v -> v.getMetricType() != null && v.getMetricType() == metricType)
					.filter(v -> isEnergyTypeMatch(v, metricType, EnergyType))
					.findFirst()
					.orElse(null);
				
				if (matchingVariable == null) {
					Core.getLogger("CalculateAssetCompleteMetrics").warn(
						"No matching variable for Asset: " + assetName + 
						", MetricType: " + metricType + ", EnergyType: " + EnergyType);
					continue;
				}
				
				// Calculate time series data
				List<IMendixObject> timeSeriesPoints = calculateMetricTimeSeries(
					context, asset, matchingVariable, metricType);
				allTimeSeriesPoints.addAll(timeSeriesPoints);
				
				// Accumuler intelligemment les totaux par EnergyType + MetricType
				double metricTotal = calculateTotalFromTimeSeries(timeSeriesPoints);
				
				// Pour Production, utiliser EnergyType de la variable (None), pas EnergyType demand√©
				smart.proxies.EnergyType effectiveEnergyType = (metricType == MetricType.Prod || metricType == MetricType.Prod_kg) 
					? matchingVariable.getEnergyType() : EnergyType;
				totals.addMetricTotal(effectiveEnergyType, metricType, metricTotal);
			}
		}
		
		// Commit and return TimeSeriesPoint list (same as CalculateSingleMetric)
		if (!allTimeSeriesPoints.isEmpty()) {
			Core.commitWithoutEvents(context, allTimeSeriesPoints);
		}
		
		// NOUVEAU : Mettre √† jour les totaux sur les Assets (d√©j√† calcul√©s)
		updateAssetTotals(context, assetTotalsMap);
		
		return allTimeSeriesPoints;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "CalculateAssetCompleteMetrics";
	}

	// BEGIN EXTRA CODE
	/**
	 * Calculate time series data for a specific metric (restored original method)
	 */
	private List<IMendixObject> calculateMetricTimeSeries(IContext context, Asset asset, 
		Variable variable, MetricType metricType) throws Exception {
		
		List<IMendixObject> timeSeriesPointList = new ArrayList<>();
		
		try {
			// Validation critique des donn√©es
			if (variable.getIIH_Id() == null || variable.getIIH_Id().trim().isEmpty()) {
				Core.getLogger("CalculateAssetCompleteMetrics").error(
					"IIH_Id manquant pour variable: " + variable.getName() + " - " + metricType);
				return timeSeriesPointList;
			}
			
			// Create calculation request
			CalculateRequest calculateRequest = smart.proxies.microflows.Microflows.calculationTimeRange(
				context, DateRange, CalculationTrend);
			
			// Setup data source
			DataSources newDataSource = new DataSources(context);
			newDataSource.setCalculateRequest_DataSources(calculateRequest);
			
			DataSource ds = new DataSource(context);
			ds.set_id(variable.getIIH_Id());
			ds.set_type(ENUM_Calculate_Type.Variable);
			ds.setAggregation(CalculationTrend.getAggregation());
			ds.setDataSource_DataSources(newDataSource);
			
			// Call IIH API
			CalculateMessage calculateMessage = iihessentialsconnector.proxies.microflows.Microflows
				.pOST_v1_8_Calculate_Trend(context, calculateRequest, null, null, null);
			
			// Check for errors
			HttpError error = calculateMessage.getHttpError_IIHMessage(context);
			if (error != null) {
				Core.getLogger("CalculateAssetCompleteMetrics").error(
					"IIH API Error for " + asset.getNom() + " - " + metricType + ": " + error.getMessage());
				return timeSeriesPointList;
			}
			
			// Process calculation results
			List<IMendixObject> calculationIMendixObjectList = Core.retrieveByPath(context, 
				calculateMessage.getMendixObject(), "IIHEssentialsConnector.Calculation_CalculateMessage");
			
			for (IMendixObject calculationIMendixObject : calculationIMendixObjectList) {
				Calculation calculation = Calculation.initialize(context, calculationIMendixObject);
				
				List<IMendixObject> valueIMendixObjectList = Core.retrieveByPath(context, 
					calculation.getMendixObject(), "IIHEssentialsConnector.CalculationValue_Calculation");
				
				for (IMendixObject valueIMendixObject : valueIMendixObjectList) {
					CalculationValue calcValue = CalculationValue.initialize(context, valueIMendixObject);
					
					if (calcValue.getValue() != null) {
						TimeSeriesPoint newPoint = new TimeSeriesPoint(context);
						newPoint.setTimeSeriesPoint_Asset(asset);
						// ‚úÖ Association Variable r√©activ√©e pour permettre l'affichage des m√©triques
						newPoint.setTimeSeriesPoint_Variable(variable);
						newPoint.setTimestamp(calcValue.getTimestamp());
						newPoint.setValue(calcValue.getValue());
						timeSeriesPointList.add(newPoint.getMendixObject());
					}
				}
			}
			
		} catch (Exception e) {
			Core.getLogger("CalculateAssetCompleteMetrics").error(
				"Error calculating metric for " + asset.getNom() + " - " + metricType + ": " + e.getMessage(), e);
		}
		
		return timeSeriesPointList;
	}
	
	/**
	 * Calcule le total d'une liste de TimeSeriesPoint
	 */
	private double calculateTotalFromTimeSeries(List<IMendixObject> timeSeriesPoints) throws Exception {
		double total = 0.0;
		for (IMendixObject tsPoint : timeSeriesPoints) {
			TimeSeriesPoint point = TimeSeriesPoint.initialize(getContext(), tsPoint);
			if (point.getValue() != null) {
				total += point.getValue().doubleValue();
			}
		}
		return total;
	}
	
	/**
	 * V√©rifie la correspondance EnergyType avec logique flexible pour Production
	 */
	private boolean isEnergyTypeMatch(Variable variable, MetricType metricType, smart.proxies.EnergyType requiredEnergyType) {
		smart.proxies.EnergyType variableEnergyType = variable.getEnergyType();
		
		// Pour les m√©triques de Production (Prod, Prod_kg), accepter EnergyType = None
		if (metricType == MetricType.Prod || metricType == MetricType.Prod_kg) {
			return variableEnergyType == smart.proxies.EnergyType.None;
		}
		
		// Pour les autres m√©triques, correspondance exacte requise
		return variableEnergyType != null && variableEnergyType == requiredEnergyType;
	}
	
	/**
	 * Met √† jour intelligemment les totaux sur les Assets
	 */
	private void updateAssetTotals(IContext context, Map<Long, AssetTotals> assetTotalsMap) throws Exception {
		List<IMendixObject> assetsToCommit = new ArrayList<>();
		
		for (AssetTotals totals : assetTotalsMap.values()) {
			// Application intelligente des totaux aux attributs Asset
			totals.applyTotalsToAsset();
			assetsToCommit.add(totals.asset.getMendixObject());
		}
		
		// Commit des Assets modifi√©s
		if (!assetsToCommit.isEmpty()) {
			Core.commitWithoutEvents(context, assetsToCommit);
		}
	}
	
	/**
	 * Classe intelligente pour accumuler et appliquer les totaux par Asset
	 * S'adapte automatiquement √† tous les attributs de totaux disponibles
	 */
	private static class AssetTotals {
		final Asset asset;
		// Map dynamique : (EnergyType, MetricGroup) -> Total
		private Map<String, Double> totalsMap = new HashMap<>();
		
		AssetTotals(Asset asset) {
			this.asset = asset;
		}
		
		/**
		 * Ajoute un total pour une combinaison EnergyType + MetricType
		 */
		void addMetricTotal(smart.proxies.EnergyType energyType, MetricType metricType, double value) {
			// Utiliser des cl√©s plus sp√©cifiques pour distinguer les modes
			String energyTypeStr = (energyType != null) ? energyType.toString() : "None";
			String key = energyTypeStr + "_" + metricType.toString();  // Plus sp√©cifique
			
			// Log de debug pour tracer les valeurs calcul√©es
			Core.getLogger("CalculateAssetCompleteMetrics").info(
				"üî¢ [Asset: " + asset.getNom() + "] Adding metric: " + key + " = " + value);
			
			totalsMap.merge(key, value, Double::sum);
		}
		

		
		/**
		 * Applique intelligemment les totaux aux attributs de l'Asset
		 */
		void applyTotalsToAsset() {
			try {
				Core.getLogger("CalculateAssetCompleteMetrics").info(
					"üîÑ [Asset: " + asset.getNom() + "] Applying totals to asset...");
				
				// Mapping intelligent des totaux aux attributs Asset
				for (Map.Entry<String, Double> entry : totalsMap.entrySet()) {
					String key = entry.getKey();
					Double value = entry.getValue();
					
					// Pattern: EnergyType_MetricType (ex: "Elec_Conso", "Elec_IPE", "Elec_IPE_kg")
					String[] parts = key.split("_", 2);  // Split en max 2 parties
					if (parts.length == 2) {
						String energyType = parts[0];
						String metricType = parts[1];
						
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"üìù [Asset: " + asset.getNom() + "] Processing: " + key + " = " + value);
						
						updateAssetAttribute(energyType, metricType, value);
					}
				}
				
				Core.getLogger("CalculateAssetCompleteMetrics").info(
					"‚úÖ [Asset: " + asset.getNom() + "] Totals applied successfully");
			} catch (Exception e) {
				Core.getLogger("CalculateAssetCompleteMetrics").error(
					"Error applying totals to asset " + asset.getNom() + ": " + e.getMessage(), e);
			}
		}
		
		/**
		 * Met √† jour l'attribut Asset correspondant avec conversion BigDecimal
		 */
		private void updateAssetAttribute(String energyType, String metricType, Double value) {
			try {
				java.math.BigDecimal bdValue = java.math.BigDecimal.valueOf(value);
				String key = energyType + "_" + metricType;
				
				// Mapping intelligent bas√© sur les patterns de nommage
				switch (key) {
					// Consommation par type d'√©nergie
					case "Elec_Conso":
						asset.setConsoTotalElec(bdValue);
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set ConsoTotalElec = " + bdValue);
						break;
					case "Gaz_Conso":
						asset.setConsoTotalGaz(bdValue);
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set ConsoTotalGaz = " + bdValue);
						break;
					case "Eau_Conso":
						asset.setConsoTotalEau(bdValue);
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set ConsoTotalEau = " + bdValue);
						break;
					case "Air_Conso":
						asset.setConsoTotalAir(bdValue);
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set ConsoTotalAir = " + bdValue);
						break;
						
					// IPE par type d'√©nergie - MODE QUANTIT√â
					case "Elec_IPE":
						asset.setIPEElec(bdValue);  // ‚úÖ Mode Quantit√©
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set IPEElec = " + bdValue);
						break;
					case "Gaz_IPE":
						asset.setIPEGaz(bdValue);  // ‚úÖ Mode Quantit√©
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set IPEGaz = " + bdValue);
						break;
					case "Eau_IPE":
						asset.setIPEEau(bdValue);  // ‚úÖ Mode Quantit√©
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set IPEEau = " + bdValue);
						break;
					case "Air_IPE":
						asset.setIPEAir(bdValue);  // ‚úÖ Mode Quantit√©
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set IPEAir = " + bdValue);
						break;
						
					// IPE par type d'√©nergie - MODE KG
					case "Elec_IPE_kg":
						asset.setIPEElecKg(bdValue);  // ‚úÖ Mode Kg
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set IPEElecKg = " + bdValue);
						break;
					case "Gaz_IPE_kg":
						asset.setIPEGazKg(bdValue);  // ‚úÖ Mode Kg
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set IPEGazKg = " + bdValue);
						break;
					case "Eau_IPE_kg":
						asset.setIPEEauKg(bdValue);  // ‚úÖ Mode Kg
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set IPEEauKg = " + bdValue);
						break;
					case "Air_IPE_kg":
						asset.setIPEAirKg(bdValue);  // ‚úÖ Mode Kg
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set IPEAirKg = " + bdValue);
						break;
						
					// Production - MODE QUANTIT√â
					case "None_Prod":
						asset.setProdTotal(bdValue);  // ‚úÖ Mode Quantit√©
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set ProdTotal = " + bdValue);
						break;
						
					// Production - MODE KG
					case "None_Prod_kg":
						asset.setProdTotalKg(bdValue);  // ‚úÖ Mode Kg
						Core.getLogger("CalculateAssetCompleteMetrics").info(
							"‚úÖ [Asset: " + asset.getNom() + "] Set ProdTotalKg = " + bdValue);
						break;
						
					default:
						Core.getLogger("CalculateAssetCompleteMetrics").warn(
							"‚ùå [Asset: " + asset.getNom() + "] No asset attribute mapping found for: " + key);
						break;
				}
					
			} catch (Exception e) {
				Core.getLogger("CalculateAssetCompleteMetrics").error(
					"‚ùå [Asset: " + asset.getNom() + "] Error setting asset attribute " + energyType + "_" + metricType + ": " + e.getMessage());
			}
		}
		
		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder();
			for (Map.Entry<String, Double> entry : totalsMap.entrySet()) {
				if (sb.length() > 0) sb.append(", ");
				sb.append(entry.getKey()).append("=").append(entry.getValue());
			}
			return sb.toString();
		}
	}

	// END EXTRA CODE
}
