// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., √©, √∂, √†, etc. are supported in comments.

package smart.actions;

import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.stream.Collectors;
import com.mendix.core.Core;
import smart.proxies.Asset;
import smart.proxies.Variable;
import smart.proxies.EnergyFlowNode;
import smart.proxies.MetricType;
import smart.proxies.EnergyType;
import smart.proxies.CalculationTrend;
import iihessentialsconnector.proxies.CalculateRequest;
import iihessentialsconnector.proxies.DataSources;
import iihessentialsconnector.proxies.DataSource;
import iihessentialsconnector.proxies.ENUM_Calculate_Type;
import iihessentialsconnector.proxies.CalculateMessage;
import iihessentialsconnector.proxies.Calculation;
import iihessentialsconnector.proxies.CalculationValue;
import iihessentialsconnector.proxies.HttpError;
import com.mendix.systemwideinterfaces.core.UserAction;

public class CalculateEnergyFlow extends CustomJavaAction<java.lang.Void>
{
	/** @deprecated use DateRange.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __DateRange;
	private final smart.proxies.DateRange DateRange;
	private final smart.proxies.MetricType MetricType;
	private final smart.proxies.EnergyType EnergyType;
	/** @deprecated use CalculationTrend.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __CalculationTrend;
	private final smart.proxies.CalculationTrend CalculationTrend;

	public CalculateEnergyFlow(
		IContext context,
		IMendixObject _dateRange,
		java.lang.String _metricType,
		java.lang.String _energyType,
		IMendixObject _calculationTrend
	)
	{
		super(context);
		this.__DateRange = _dateRange;
		this.DateRange = _dateRange == null ? null : smart.proxies.DateRange.initialize(getContext(), _dateRange);
		this.MetricType = _metricType == null ? null : smart.proxies.MetricType.valueOf(_metricType);
		this.EnergyType = _energyType == null ? null : smart.proxies.EnergyType.valueOf(_energyType);
		this.__CalculationTrend = _calculationTrend;
		this.CalculationTrend = _calculationTrend == null ? null : smart.proxies.CalculationTrend.initialize(getContext(), _calculationTrend);
	}

	@java.lang.Override
	public java.lang.Void executeAction() throws Exception
	{
		// BEGIN USER CODE
		IContext context = getContext();
		
		// Validation des param√®tres d'entr√©e
		if (DateRange == null) {
			throw new Exception("DateRange manquant");
		}
		if (MetricType == null) {
			throw new Exception("MetricType manquant");
		}
		if (EnergyType == null) {
			throw new Exception("EnergyType manquant");
		}
		if (CalculationTrend == null) {
			throw new Exception("CalculationTrend manquant");
		}
		
		Core.getLogger("CalculateEnergyFlow").info(
			"üöÄ Starting CalculateEnergyFlow - EnergyType: " + EnergyType + 
			", MetricType: " + MetricType);
		
		// R√©cup√©rer tous les EnergyFlowNodes existants
		List<EnergyFlowNode> energyFlowNodes = EnergyFlowNode.load(context, "");
		if (energyFlowNodes.isEmpty()) {
			Core.getLogger("CalculateEnergyFlow").warn("Aucun EnergyFlowNode trouv√© dans la base de donn√©es");
			return null;
		}
		
		Core.getLogger("CalculateEnergyFlow").info("üìä Found " + energyFlowNodes.size() + " EnergyFlowNodes to update");
		
		// Regrouper les flux par parent (Asset source)
		Map<Long, List<EnergyFlowNode>> flowsByParent = new HashMap<>();
		
		// 1) Calculer les flowValue pour chaque lien et alimenter le regroupement
		for (EnergyFlowNode flowNode : energyFlowNodes) {
			try {
				// R√©cup√©rer les assets source et target
				Asset sourceAsset = flowNode.getSourceAsset(context);
				Asset targetAsset = flowNode.getTargetAsset(context);
				
				// Accepte un flux ROOT: sourceAsset peut √™tre nul (origine virtuelle)
				if (targetAsset == null) {
					Core.getLogger("CalculateEnergyFlow").warn("Target asset manquant pour EnergyFlowNode: " + flowNode.getMendixObject().getId());
					continue;
				}
				
				Core.getLogger("CalculateEnergyFlow").info("üîÑ Processing flow: " + (sourceAsset != null ? sourceAsset.getNom() : "ROOT") + " ‚Üí " + targetAsset.getNom());
				
				// Calculer la valeur pour l'asset target (c'est la valeur du flux)
				java.math.BigDecimal flowValue = calculateAssetValue(context, targetAsset, CalculationTrend);
				flowNode.setFlowValue(flowValue);
				
				// Alimenter le regroupement par parent pour normalisation ult√©rieure
				Long parentId = sourceAsset != null ? sourceAsset.getMendixObject().getId().toLong() : -1L; // -1 = groupe ROOT
				flowsByParent.computeIfAbsent(parentId, k -> new ArrayList<>()).add(flowNode);
				
			} catch (Exception e) {
				Core.getLogger("CalculateEnergyFlow").error("‚ùå Error processing EnergyFlowNode: " + e.getMessage(), e);
			}
		}
		
		// 2) Normaliser les pourcentages par parent: somme des enfants = 100%
		for (Map.Entry<Long, List<EnergyFlowNode>> entry : flowsByParent.entrySet()) {
			List<EnergyFlowNode> childrenFlows = entry.getValue();
			java.math.BigDecimal totalChildren = java.math.BigDecimal.ZERO;
			for (EnergyFlowNode childFlow : childrenFlows) {
				java.math.BigDecimal v = childFlow.getFlowValue();
				if (v != null) {
					totalChildren = totalChildren.add(v);
				}
			}
			
			if (totalChildren.compareTo(java.math.BigDecimal.ZERO) > 0) {
				for (EnergyFlowNode childFlow : childrenFlows) {
					java.math.BigDecimal v = childFlow.getFlowValue();
					if (v == null) v = java.math.BigDecimal.ZERO;
					java.math.BigDecimal pct = v.multiply(new java.math.BigDecimal("100"))
						.divide(totalChildren, 2, java.math.RoundingMode.HALF_UP);
					childFlow.setPercentage(pct);
				}
			} else {
				// Aucun flux enfant non‚Äënul: 0% pour tous
				for (EnergyFlowNode childFlow : childrenFlows) {
					childFlow.setPercentage(java.math.BigDecimal.ZERO);
				}
			}
		}
		
		// Commit tous les changements
		List<IMendixObject> flowNodeObjects = new ArrayList<>();
		for (EnergyFlowNode flowNode : energyFlowNodes) {
			flowNodeObjects.add(flowNode.getMendixObject());
		}
		Core.commit(context, flowNodeObjects);
		
		Core.getLogger("CalculateEnergyFlow").info("‚úÖ CalculateEnergyFlow completed successfully");
		
		return null;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "CalculateEnergyFlow";
	}

	// BEGIN EXTRA CODE
	
	/**
	 * Calcule la valeur d'un asset via l'API IIH pour le MetricType et EnergyType sp√©cifi√©s
	 */
	private java.math.BigDecimal calculateAssetValue(IContext context, Asset asset, CalculationTrend calculationTrend) throws Exception {
		java.math.BigDecimal totalValue = java.math.BigDecimal.ZERO;
		
		try {
			// üÜï Si on utilisait un asset racine virtuel, on le d√©tectait par le nom. Ce cas n'est plus n√©cessaire
			// car la racine est repr√©sent√©e par des EnergyFlowNode avec source nulle.
			
			// Trouver la variable correspondante pour cet asset, MetricType et EnergyType
			Variable matchingVariable = findMatchingVariable(context, asset);
			
			if (matchingVariable == null) {
				Core.getLogger("CalculateEnergyFlow").warn(
					"Aucune variable trouv√©e pour Asset: " + asset.getNom() + 
					", MetricType: " + MetricType + ", EnergyType: " + EnergyType);
				return totalValue;
			}
			
			// Validation de l'IIH_Id
			if (matchingVariable.getIIH_Id() == null || matchingVariable.getIIH_Id().trim().isEmpty()) {
				Core.getLogger("CalculateEnergyFlow").error(
					"IIH_Id manquant pour variable: " + matchingVariable.getName());
				return totalValue;
			}
			
			// Create calculation request
			CalculateRequest calculateRequest = smart.proxies.microflows.Microflows.calculationTimeRange(
				context, DateRange, calculationTrend);
			
			// Setup data source
			DataSources newDataSource = new DataSources(context);
			newDataSource.setCalculateRequest_DataSources(calculateRequest);
			
			DataSource ds = new DataSource(context);
			ds.set_id(matchingVariable.getIIH_Id());
			ds.set_type(ENUM_Calculate_Type.Variable);
			ds.setAggregation(calculationTrend.getAggregation());
			ds.setDataSource_DataSources(newDataSource);
			
			// Call IIH API
			CalculateMessage calculateMessage = iihessentialsconnector.proxies.microflows.Microflows
				.pOST_v1_8_Calculate_Trend(context, calculateRequest, null, null, null);
			
			// Check for errors
			HttpError error = calculateMessage.getHttpError_IIHMessage(context);
			if (error != null) {
				Core.getLogger("CalculateEnergyFlow").error(
					"IIH API Error for " + asset.getNom() + ": " + error.getMessage());
				return totalValue;
			}
			
			// Process calculation results and sum all values
			List<IMendixObject> calculationIMendixObjectList = Core.retrieveByPath(context, 
				calculateMessage.getMendixObject(), "IIHEssentialsConnector.Calculation_CalculateMessage");
			
			for (IMendixObject calculationIMendixObject : calculationIMendixObjectList) {
				Calculation calculation = Calculation.initialize(context, calculationIMendixObject);
				
				List<IMendixObject> valueIMendixObjectList = Core.retrieveByPath(context, 
					calculation.getMendixObject(), "IIHEssentialsConnector.CalculationValue_Calculation");
				
				for (IMendixObject valueIMendixObject : valueIMendixObjectList) {
					CalculationValue calcValue = CalculationValue.initialize(context, valueIMendixObject);
					
					if (calcValue.getValue() != null) {
						totalValue = totalValue.add(calcValue.getValue());
					}
				}
			}
			
			Core.getLogger("CalculateEnergyFlow").info(
				"üìä Calculated total value for " + asset.getNom() + ": " + totalValue);
			
		} catch (Exception e) {
			Core.getLogger("CalculateEnergyFlow").error(
				"Error calculating value for " + asset.getNom() + ": " + e.getMessage(), e);
		}
		
		return totalValue;
	}
	
	/**
	 * üÜï NOUVELLE M√âTHODE : Calculer la valeur du root virtuel
	 */
	// Plus de calcul sp√©cifique pour un asset root virtuel ‚Äî la racine est implicite (source nulle)
	
	/**
	 * Trouve la variable correspondante pour un asset, MetricType et EnergyType
	 */
	private Variable findMatchingVariable(IContext context, Asset asset) throws Exception {
		// R√©cup√©rer toutes les variables de l'asset
		List<Variable> variableList = Variable.load(context, 
			"[Smart.Variable_Asset = " + asset.getMendixObject().getId().toLong() + "]");
		
		// Trouver la variable correspondante avec logique flexible pour Production
		return variableList.stream()
			.filter(v -> v.getMetricType() != null && v.getMetricType() == MetricType)
			.filter(v -> isEnergyTypeMatch(v, MetricType, EnergyType))
			.findFirst()
			.orElse(null);
	}
	
	/**
	 * V√©rifie la correspondance EnergyType avec logique flexible pour Production
	 */
	private boolean isEnergyTypeMatch(Variable variable, MetricType metricType, EnergyType requiredEnergyType) {
		EnergyType variableEnergyType = variable.getEnergyType();
		
		// Pour les m√©triques de Production (Prod, Prod_kg), accepter EnergyType = None
		if (metricType == MetricType.Prod || metricType == MetricType.Prod_kg) {
			return variableEnergyType == EnergyType.None;
		}
		
		// Pour les autres m√©triques, correspondance exacte requise
		return variableEnergyType != null && variableEnergyType == requiredEnergyType;
	}
	
	/**
	 * R√©cup√®re la valeur actuelle d'un asset selon EnergyType et MetricType
	 */
	private java.math.BigDecimal getAssetValue(Asset asset) {
		try {
			java.math.BigDecimal value = java.math.BigDecimal.ZERO;
			
			// Mapping bas√© sur les enums (m√™me logique que dans CreateEnergyFlowNodes)
			if (MetricType == MetricType.Conso) {
				switch (EnergyType) {
					case Elec:
						value = asset.getConsoTotalElec();
						break;
					case Gaz:
						value = asset.getConsoTotalGaz();
						break;
					case Eau:
						value = asset.getConsoTotalEau();
						break;
					case Air:
						value = asset.getConsoTotalAir();
						break;
				}
			} else if (MetricType == MetricType.IPE) {
				switch (EnergyType) {
					case Elec:
						value = asset.getIPEElec();
						break;
					case Gaz:
						value = asset.getIPEGaz();
						break;
					case Eau:
						value = asset.getIPEEau();
						break;
					case Air:
						value = asset.getIPEAir();
						break;
				}
			} else if (MetricType == MetricType.IPE_kg) {
				switch (EnergyType) {
					case Elec:
						value = asset.getIPEElecKg();
						break;
					case Gaz:
						value = asset.getIPEGazKg();
						break;
					case Eau:
						value = asset.getIPEEauKg();
						break;
					case Air:
						value = asset.getIPEAirKg();
						break;
				}
			} else if (MetricType == MetricType.Prod) {
				value = asset.getProdTotal();
			} else if (MetricType == MetricType.Prod_kg) {
				value = asset.getProdTotalKg();
			}
			
			return value != null ? value : java.math.BigDecimal.ZERO;
			
		} catch (Exception e) {
			Core.getLogger("CalculateEnergyFlow").error(
				"Error getting asset value for " + asset.getNom() + ": " + e.getMessage());
			return java.math.BigDecimal.ZERO;
		}
	}
	
	/**
	 * Calcule le pourcentage
	 */
	private java.math.BigDecimal calculatePercentage(java.math.BigDecimal value, java.math.BigDecimal total) {
		if (total.compareTo(java.math.BigDecimal.ZERO) == 0) {
			// Si la valeur source est 0, attribuer 100% (logique de test)
			Core.getLogger("CalculateEnergyFlow").info(
				"üîç calculatePercentage - Total is 0, using 100% for test environment");
			return new java.math.BigDecimal("100");
		}
		return value.multiply(new java.math.BigDecimal("100"))
			.divide(total, 2, java.math.RoundingMode.HALF_UP);
	}
	
	// END EXTRA CODE
}
