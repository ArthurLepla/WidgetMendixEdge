// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., √©, √∂, √†, etc. are supported in comments.

package smart.actions;

import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.logging.ILogNode;
import smart.proxies.Features;
import smart.proxies.FeatureToggle;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class FeatureToggleService extends CustomJavaAction<java.lang.Boolean>
{
	private final java.lang.String FeatureName;
	private final java.lang.String Operation;

	public FeatureToggleService(
		IContext context,
		java.lang.String _featureName,
		java.lang.String _operation
	)
	{
		super(context);
		this.FeatureName = _featureName;
		this.Operation = _operation;
	}

	@java.lang.Override
	public java.lang.Boolean executeAction() throws Exception
	{
		// BEGIN USER CODE
        IContext context = getContext();
        
        // Validation des param√®tres
        if (FeatureName == null || FeatureName.trim().isEmpty()) {
            getLogger().warn("‚ö†Ô∏è FeatureName is null or empty");
            return false;
        }
        
        if (Operation == null || Operation.trim().isEmpty()) {
            getLogger().warn("‚ö†Ô∏è Operation is null or empty");
            return false;
        }
        
        // Conversion s√©curis√©e de la feature
        Features feature;
        try {
            feature = Features.valueOf(FeatureName.trim());
        } catch (IllegalArgumentException e) {
            getLogger().error("‚ùå Invalid feature name: " + FeatureName);
            return false;
        }
        
        switch (Operation.toLowerCase().trim()) {
            case "isenabled":
                return isFeatureEnabled(context, feature);
            case "getconfig":
                String config = getFeatureConfig(context, feature);
                // Pour retourner la config, on va cr√©er une autre action s√©par√©e
                return config != null && !config.isEmpty();
            case "invalidatecache":
                invalidateCache();
                getLogger().info("üîÑ Feature toggles cache invalidated");
                return true;
            default:
                getLogger().warn("‚ö†Ô∏è Unknown operation: " + Operation);
                return false;
        }
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "FeatureToggleService";
	}

	// BEGIN EXTRA CODE
    /* ==== CACHE ET CONFIGURATION ==== */
    private static final Map<Features, FeatureToggle> cache = new ConcurrentHashMap<>();
    private static volatile long lastRefresh = 0;
    private static final long CACHE_TTL = 5 * 60 * 1000; // 5 minutes en millisecondes
    private static final ILogNode LOG = Core.getLogger("FeatureToggleService");
    
    /**
     * V√©rifie si une feature est activ√©e
     */
    public static boolean isFeatureEnabled(IContext context, Features feature) {
        if (feature == null) {
            LOG.warn("‚ö†Ô∏è Feature null passed to isFeatureEnabled");
            return false;
        }
        
        try {
            refreshCacheIfNeeded(context);
            FeatureToggle toggle = cache.get(feature);
            
            boolean isEnabled = toggle != null && Boolean.TRUE.equals(toggle.getIsEnabled());
            
            LOG.debug("üîç Feature " + feature.name() + " is " + (isEnabled ? "ENABLED" : "DISABLED"));
            return isEnabled;
            
        } catch (Exception e) {
            LOG.error("‚ùå Error checking feature " + feature.name() + ": " + e.getMessage(), e);
            return false; // Fail-safe : d√©sactiv√© par d√©faut en cas d'erreur
        }
    }
    
    /**
     * R√©cup√®re la configuration d'une feature
     */
    public static String getFeatureConfig(IContext context, Features feature) {
        if (feature == null) {
            LOG.warn("‚ö†Ô∏è Feature null passed to getFeatureConfig");
            return "";
        }
        
        try {
            refreshCacheIfNeeded(context);
            FeatureToggle toggle = cache.get(feature);
            
            String config = toggle != null ? toggle.getConfigurationValue() : "";
            if (config == null) config = "";
            
            LOG.debug("üîß Feature " + feature.name() + " config: " + 
                     (config.isEmpty() ? "(empty)" : config.substring(0, Math.min(50, config.length()))));
            return config;
            
        } catch (Exception e) {
            LOG.error("‚ùå Error getting config for feature " + feature.name() + ": " + e.getMessage(), e);
            return ""; // Fail-safe : config vide en cas d'erreur
        }
    }
    
    /**
     * Invalide le cache (force le rechargement)
     */
    public static void invalidateCache() {
        cache.clear();
        lastRefresh = 0;
        LOG.info("üîÑ Feature toggles cache cleared");
    }
    
    /**
     * Recharge le cache si n√©cessaire (TTL expir√©)
     */
    private static synchronized void refreshCacheIfNeeded(IContext context) throws Exception {
        long now = System.currentTimeMillis();
        
        if (now - lastRefresh > CACHE_TTL || cache.isEmpty()) {
            LOG.debug("üîÑ Refreshing feature toggles cache...");
            
            // Vider le cache existant
            cache.clear();
            
            // Charger toutes les feature toggles depuis la DB
            List<FeatureToggle> allToggles = FeatureToggle.load(context, "");
            
            for (FeatureToggle toggle : allToggles) {
                Features feature = toggle.getFeatureName();
                if (feature != null) {
                    cache.put(feature, toggle);
                }
            }
            
            lastRefresh = now;
            LOG.info("‚úÖ Feature toggles cache refreshed - " + cache.size() + " features loaded");
        }
    }
    
    /**
     * Warm-up du cache au d√©marrage de l'application
     */
    public static void warmUpCache(IContext context) {
        try {
            LOG.info("üî• Warming up feature toggles cache...");
            refreshCacheIfNeeded(context);
            
            // Log du statut de chaque feature pour debug
            LOG.info("üìä Feature toggles status:");
            for (Map.Entry<Features, FeatureToggle> entry : cache.entrySet()) {
                Features feature = entry.getKey();
                boolean enabled = Boolean.TRUE.equals(entry.getValue().getIsEnabled());
                LOG.info("   ‚Ä¢ " + feature.name() + ": " + (enabled ? "‚úÖ ENABLED" : "‚ùå DISABLED"));
            }
            
        } catch (Exception e) {
            LOG.error("‚ùå Error warming up feature toggles cache: " + e.getMessage(), e);
        }
    }
    
    /**
     * Statistiques du cache (pour monitoring)
     */
    public static String getCacheStats() {
        return String.format("Cache size: %d, Last refresh: %d ms ago", 
                           cache.size(), 
                           System.currentTimeMillis() - lastRefresh);
    }
    
    private static ILogNode getLogger() {
        return LOG;
    }
	// END EXTRA CODE
}
