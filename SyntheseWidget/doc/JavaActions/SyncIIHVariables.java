// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., √©, √∂, √†, etc. are supported in comments.

package smart.actions;

import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.core.Core;
import com.mendix.logging.ILogNode;
import smart.proxies.Asset;
import smart.proxies.Variable;
import smart.proxies.SyncMetadata;
import smart.proxies.SyncStatus;
import smart.proxies.MetricType;
import smart.proxies.EnergyType;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.Date;
import java.lang.Boolean;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.HashMap;
import java.util.Map;
import com.mendix.systemwideinterfaces.core.UserAction;

public class SyncIIHVariables extends CustomJavaAction<IMendixObject>
{
	/** @deprecated use syncMetadata.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __syncMetadata;
	private final smart.proxies.SyncMetadata syncMetadata;
	private final java.lang.Boolean isScheduledMode;
	private final java.lang.Long BATCH_SIZE;
	private final java.lang.Boolean testLocal;

	public SyncIIHVariables(
		IContext context,
		IMendixObject _syncMetadata,
		java.lang.Boolean _isScheduledMode,
		java.lang.Long _bATCH_SIZE,
		java.lang.Boolean _testLocal
	)
	{
		super(context);
		this.__syncMetadata = _syncMetadata;
		this.syncMetadata = _syncMetadata == null ? null : smart.proxies.SyncMetadata.initialize(getContext(), _syncMetadata);
		this.isScheduledMode = _isScheduledMode;
		this.BATCH_SIZE = _bATCH_SIZE;
		this.testLocal = _testLocal;
	}

	@java.lang.Override
	public IMendixObject executeAction() throws Exception
	{
		// BEGIN USER CODE
		IContext ctx = getContext();
		
		// === NETTOYAGE DES VARIABLES AVANT SYNCHRO ===
		cleanupVariables(ctx);
		getLogger().info("üßπ Nettoyage initial : anciennes Variables supprim√©es");
		
		getLogger().info("=== SYNCHRONISATION VARIABLES IIH ===");
		getLogger().info("‚öôÔ∏è Mode: " + (isScheduledMode ? "Batch" : "Temps r√©el"));
		getLogger().info("üì¶ Batch size: " + BATCH_SIZE);
		getLogger().info("üåê URL IIH: http://localhost:4203");

		// ‚úÖ STRAT√âGIE SIMPLIFI√âE - Pas de v√©rification des assets IIH
		// On utilise directement les assets Smart cr√©√©s par ProcessIIHAssetTree
		getLogger().info("üéØ Strat√©gie: Utilisation des assets Smart existants pour r√©cup√©rer les variables");
		
		// Pas de v√©rification des assets IIH - on fait confiance aux assets Smart
		// if (iihAssetsCount == 0) { ... } - SUPPRIM√â

		VariableStats stats = new VariableStats();
		List<IMendixObject> buffer = new ArrayList<>();
		long startTime = System.currentTimeMillis();

		try {
			// R√©cup√©rer tous les assets Smart (sauf root avec IIH_Id = "0")
			List<Asset> smartAssets = getSmartAssetsExcludingRoot(ctx);
			getLogger().info("üéØ Assets Smart √† traiter: " + smartAssets.size());
			
			if (smartAssets.isEmpty()) {
				getLogger().warn("‚ö†Ô∏è Aucun asset Smart trouv√© ! V√©rifiez que la sync Assets a bien fonctionn√©");
				return syncMetadata != null ? syncMetadata.getMendixObject() : null;
			}

			// LOG: √âchantillon d'assets √† traiter
			getLogger().info("üìã Premiers assets √† traiter:");
			for (int i = 0; i < Math.min(5, smartAssets.size()); i++) {
				Asset asset = smartAssets.get(i);
				getLogger().info("   - " + asset.getIIH_Id() + " (" + asset.getNom() + ")");
			}
			if (smartAssets.size() > 5) {
				getLogger().info("   ... et " + (smartAssets.size() - 5) + " autres");
			}

			/* ------------- DEBUG - AJOUTER CETTE M√âTHODE TEMPORAIRE ------------- */
			// debugVariableMapping(ctx, stats);

			// Traiter chaque asset
			for (Asset asset : smartAssets) {
				try {
					processAssetVariables(ctx, asset, buffer, stats);
					
					// Progress reporting
					if (isScheduledMode && stats.assetsProcessed % 5 == 0) {
						double progress = (double) stats.assetsProcessed / smartAssets.size() * 100;
						getLogger().info("üìä Progress: " + stats.assetsProcessed + "/" + smartAssets.size() + 
										" (" + String.format("%.1f", progress) + "%) - " + 
										stats.variablesProcessed + " variables, " + 
										stats.iihApiCalls + " API calls");
					}
					
				} catch (Exception e) {
					stats.errors++;
					getLogger().error("‚ùå Erreur asset " + asset.getIIH_Id() + ": " + e.getMessage());
					// Continuer avec les autres assets
				}
			}

			// Commit final
			if (!buffer.isEmpty()) {
				getLogger().info("üì¶ Final commit en cours: " + buffer.size() + " variables...");
				Core.commitWithoutEvents(ctx, buffer);
				stats.variablesCommitted += buffer.size();
				getLogger().info("‚úÖ Final commit termin√©: " + buffer.size() + " variables");
			}

			// üÜï Mise √† jour des flags √©nergie sur les assets
			batchUpdateAssetEnergyFlags(ctx, stats);

			// Mettre √† jour les m√©tadonn√©es
			long duration = System.currentTimeMillis() - startTime;
			updateSyncMetadata(ctx, stats, duration, null);

		} catch (Exception e) {
			long duration = System.currentTimeMillis() - startTime;
			getLogger().error("üí• Erreur critique sync variables: " + e.getMessage(), e);
			updateSyncMetadata(ctx, stats, duration, e);
			throw e;
		}

		// Logs finaux
		logFinalVariableStats(stats, System.currentTimeMillis() - startTime);
		
		return syncMetadata != null ? syncMetadata.getMendixObject() : null;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "SyncIIHVariables";
	}

	// BEGIN EXTRA CODE
	/* ==== LOGGER ==== */
	private static final ILogNode LOG = Core.getLogger("IIHVariableSync");
	
	// üêõ DEBUG - Flag pour contr√¥ler les logs de debug 
	// UTILISATION :
	// 1. Laisser √† TRUE pour diagnostiquer le probl√®me EnergyType
	// 2. Examiner les logs g√©n√©r√©s pour comprendre pourquoi '√©lectricit√©' n'est pas reconnu  
	// 3. Une fois le probl√®me r√©solu, mettre √† FALSE pour retirer les logs
	private static final boolean DEBUG_ENERGY_PARSING = true;

	// ‚ûï NEW: regex pour extraire <metric>_<energy> (ex: consommation_elec)
	private static final Pattern VAR_REGEX = Pattern.compile("(?i)^([a-z0-9√©√®√™√†_]+)_([a-z]+)$");

	private ILogNode getLogger() {
		return LOG;
	}
	
	// üêõ DEBUG Helper - Log conditionnel pour debug parsing
	private void debugLog(String message) {
		if (DEBUG_ENERGY_PARSING) {
			getLogger().info(message);
		}
	}

	/* ==== STATISTIQUES VARIABLES ==== */
	private static class VariableStats {
		int assetsProcessed = 0;
		int variablesProcessed = 0;
		int variablesCreated = 0;
		int variablesUpdated = 0;
		int variablesCommitted = 0;
		int iihApiCalls = 0;
		int errors = 0;
		
		// ‚úÖ AJOUT - Cache pour optimiser les appels API
		private List<iihessentialsconnector.proxies.Variable> cachedAllVariables = null;
		private boolean apiCallMade = false;
		// üÜï cache des flags √©nergie par asset
		private Map<String, AssetFlags> assetFlags = new HashMap<>();
	}

	// üÜï Structure interne pour stocker les flags √©nergie d'un asset
	private static class AssetFlags {
		boolean elec = false;
		boolean gaz  = false;
		boolean eau  = false;
		boolean air  = false;
	}

	// üÜï R√©sultat du parsing d'un nom de variable
	private static class ParseResult {
		MetricType metricType;
		EnergyType energyType;
		
		ParseResult(MetricType metric, EnergyType energy) {
			this.metricType = metric;
			this.energyType = energy;
		}
	}

	// üÜï Helper pour r√©cup√©rer ou cr√©er le cache de flags d'un asset
	private AssetFlags getAssetFlags(VariableStats stats, Asset asset) {
		return stats.assetFlags.computeIfAbsent(asset.getIIH_Id(), k -> new AssetFlags());
	}

	/* ------------- R√âCUP√âRER ASSETS SMART - VERSION CORRIG√âE ------------- */
	private List<Asset> getSmartAssetsExcludingRoot(IContext ctx) throws Exception {
	    
	    // ‚úÖ R√©cup√©rer TOUS les assets Smart
	    List<IMendixObject> assetObjects = Core.retrieveXPathQuery(ctx, "//Smart.Asset");
	    
	    List<Asset> assets = new ArrayList<>();
	    getLogger().info("üìä " + assetObjects.size() + " assets Smart trouv√©s au total");
	    
	    for (IMendixObject assetObj : assetObjects) {
	        Asset asset = Asset.initialize(ctx, assetObj);
	        
	        String iihId = asset.getIIH_Id();
	        String nom = asset.getNom();
	        
	        // ‚úÖ DEBUG - Log de chaque asset pour comprendre le filtrage
	        getLogger().info("üîç Asset trouv√©: '" + nom + "' | IIH_Id: '" + iihId + "'");
	        
	        // ‚úÖ CORRECTION - Filtrer UNIQUEMENT les assets root (IIH_Id = "0")
	        if (iihId != null && !"0".equals(iihId) && !iihId.trim().isEmpty()) {
	            
	            // ‚úÖ SUPPRESSION du filtre sur le parent - Garder TOUS les assets non-root
	            assets.add(asset);
	            getLogger().info("   ‚úÖ Asset ajout√©: " + nom + " (" + iihId + ")");
	            
	            /* ANCIEN CODE PROBL√âMATIQUE :
	            try {
	                Asset parent = asset.getAsset_Parent();
	                if (parent != null) {
	                    assets.add(asset);
	                }
	            } catch (Exception e) {
	                if (!"0".equals(asset.getIIH_Id())) {
	                    assets.add(asset);
	                }
	            }
	            */
	        } else {
	            getLogger().info("   ‚ùå Asset exclu (root): " + nom + " (" + iihId + ")");
	        }
	    }
	    
	    getLogger().info("üìä " + assets.size() + " assets Smart s√©lectionn√©s (root exclu)");
	    
	    // ‚úÖ DEBUG - Liste finale des assets s√©lectionn√©s
	    getLogger().info("üìã Assets Smart s√©lectionn√©s:");
	    for (Asset asset : assets) {
	        getLogger().info("   üìÑ " + asset.getNom() + " (" + asset.getIIH_Id() + ")");
	    }
	    
	    return assets;
	}

	/* ------------- TRAITER VARIABLES D'UN ASSET ------------- */
	private void processAssetVariables(IContext ctx, Asset asset, List<IMendixObject> buffer, 
									   VariableStats stats) throws Exception {
		
		stats.assetsProcessed++;
		String assetId = asset.getIIH_Id();
		String assetName = asset.getNom();
		
		getLogger().info("üîÑ [" + stats.assetsProcessed + "] Traitement variables pour: " + 
						assetId + " (" + assetName + ")");

		try {
			// Appeler l'API IIH pour r√©cup√©rer les variables de cet asset
			List<iihessentialsconnector.proxies.Variable> iihVariables = 
				loadVariablesFromIIH(ctx, assetId, stats);

			if (iihVariables.isEmpty()) {
				getLogger().debug("   üìÑ Aucune variable pour asset: " + assetName);
				return;
			}

			getLogger().info("   ‚úÖ " + iihVariables.size() + " variables trouv√©es pour: " + assetName);

			// Traiter chaque variable
			for (iihessentialsconnector.proxies.Variable iihVar : iihVariables) {
				try {
					processVariable(ctx, iihVar, asset, buffer, stats);
				} catch (Exception e) {
					stats.errors++;
					String varName = iihVar != null ? iihVar.getVariableName() : "null";
					getLogger().error("‚ùå Erreur variable " + varName + 
									" (asset " + assetName + "): " + e.getMessage());
				}
			}
			
			getLogger().debug("   ‚úÖ Variables trait√©es pour: " + assetName);

		} catch (Exception e) {
			stats.errors++;
			getLogger().error("‚ùå Erreur globale asset " + assetName + ": " + e.getMessage(), e);
		}
	}

	/* ------------- M√âTHODE loadVariablesFromIIH - DEBUG FINAL ------------- */
	private List<iihessentialsconnector.proxies.Variable> loadVariablesFromIIH(
	        IContext ctx, String assetId, VariableStats stats) throws Exception {
	    try {
	        if (!stats.apiCallMade) {
	            stats.iihApiCalls++;
	            stats.apiCallMade = true;
	            getLogger().info("üåê Appel API Variables (r√©cup√©ration compl√®te sans filtrage)");
	            String iihUrl = (testLocal != null && testLocal) ? "http://localhost:4203" : null;
	            getLogger().debug("üåê URL IIH utilis√©e: " + iihUrl);
	            IMendixObject resultObject = (IMendixObject) Core.microflowCall("IIHEssentialsConnector.GET_v1_8_Variables_All")
	                .withParam("IIHEssentialsURL_RequiredIfExternal", iihUrl)
	                .withParam("DecryptedDeviceToken_RequiredIfExternal", (String) null)
	                .withParam("AspectList_Optional", (List<iihessentialsconnector.proxies.Aspect>) null)
	                .withParam("VariableList_Optional", (List<iihessentialsconnector.proxies.Variable>) null)
	                .withParam("AssetList_Optional", (List<iihessentialsconnector.proxies.Asset>) null)
	                .withParam("AdapterList_Optional", (List<iihessentialsconnector.proxies.Adapter>) null)
	                .execute(ctx);
	            stats.cachedAllVariables = new ArrayList<>();
	            if (resultObject != null) {
	                iihessentialsconnector.proxies.VariablesMessage result = 
	                    iihessentialsconnector.proxies.VariablesMessage.initialize(ctx, resultObject);
	                List<IMendixObject> allVariableObjects = Core.retrieveByPath(ctx, result.getMendixObject(), 
	                    "IIHEssentialsConnector.Variable_VariablesMessage");
	                getLogger().info("üìä " + allVariableObjects.size() + " variables totales r√©cup√©r√©es depuis l'API");
	                for (IMendixObject varObj : allVariableObjects) {
	                    iihessentialsconnector.proxies.Variable iihVar = 
	                        iihessentialsconnector.proxies.Variable.initialize(ctx, varObj);
	                    // DEBUG FINAL - Log structure compl√®te
	                    String objectId = iihVar.getObjectId();
	                    String variableName = iihVar.getVariableName();
	                    String assetIdVar = iihVar.getAssetId();
	                    String dataType = iihVar.getDataType();
	                    String unit = iihVar.getUnit();
	                    String topic = iihVar.getTopic();
	                    String aspectId = iihVar.getAspectId();
	                    String aspectName = iihVar.getAspectName();
	                    String adapterId = iihVar.getAdapterId();
	                    Boolean connected = iihVar.getConnected();
	                    Boolean store = iihVar.getStore();
	                    getLogger().info("üîç === VARIABLE IIH COMPL√àTE ===");
	                    getLogger().info("   üÜî ObjectId (ID UNIQUE): '" + objectId + "'");
	                    getLogger().info("   üìõ VariableName (NOM): '" + variableName + "'");
	                    getLogger().info("   üè¢ AssetId: '" + assetIdVar + "'");
	                    getLogger().info("   üìä DataType: '" + dataType + "'");
	                    getLogger().info("   üìè Unit: '" + unit + "'");
	                    getLogger().info("   üì° Topic: '" + topic + "'");
	                    getLogger().info("   üéØ AspectId: '" + aspectId + "'");
	                    getLogger().info("   üè∑Ô∏è AspectName: '" + aspectName + "'");
	                    getLogger().info("   üîå AdapterId: '" + adapterId + "'");
	                    getLogger().info("   ‚úÖ Connected: " + connected);
	                    getLogger().info("   üíæ Store: " + store);
	                    stats.cachedAllVariables.add(iihVar);
	                }
	                getLogger().info("üìä " + stats.cachedAllVariables.size() + " variables totales mises en cache (sans filtrage)");
	            } else {
	                getLogger().warn("‚ö†Ô∏è R√©ponse API null - cache vide");
	            }
	        }
	        List<iihessentialsconnector.proxies.Variable> variables = new ArrayList<>();
	        if (stats.cachedAllVariables != null) {
	            getLogger().info("üîç Recherche de variables pour asset: '" + assetId + "'");
	            for (iihessentialsconnector.proxies.Variable iihVar : stats.cachedAllVariables) {
	                String varAssetId = iihVar.getAssetId();
	                String varName = iihVar.getVariableName();
	                getLogger().debug("   üîç Comparaison: AssetId demand√©='" + assetId + "' vs Variable AssetId='" + varAssetId + "'");
	                boolean isMatch = false;
	                if (assetId.equals(varAssetId)) {
	                    isMatch = true;
	                    getLogger().info("   ‚úÖ MATCH EXACT: " + varName + " (AssetId: " + varAssetId + ")");
	                }
	                else if (varAssetId != null && assetId.equalsIgnoreCase(varAssetId)) {
	                    isMatch = true;
	                    getLogger().info("   ‚úÖ MATCH CASSE: " + varName + " (AssetId: " + varAssetId + ")");
	                }
	                else if (varAssetId != null && (assetId.startsWith(varAssetId) || varAssetId.startsWith(assetId))) {
	                    isMatch = true;
	                    getLogger().info("   ‚úÖ MATCH PARTIEL: " + varName + " (AssetId: " + varAssetId + ")");
	                }
	                if (isMatch) {
	                    variables.add(iihVar);
	                }
	            }
	        }
	        getLogger().info("‚úÖ " + variables.size() + " variables trouv√©es pour asset: " + assetId);
	        return variables;
	    } catch (Exception e) {
	        stats.errors++;
	        getLogger().error("‚ùå Erreur API Variables pour asset " + assetId + ": " + e.getMessage(), e);
	        if (e.getMessage() != null && 
	            (e.getMessage().contains("Connection") || e.getMessage().contains("timeout"))) {
	            getLogger().error("üåê Probl√®me de connexion √† IIH - V√©rifiez que http://localhost:4203 est accessible");
	        }
	        return new ArrayList<>();
	    }
	}

	/* ------------- PROCESSVARIABLE ‚Äì VERSION ENUM-READY ------------- */
	private void processVariable(IContext ctx,
								 iihessentialsconnector.proxies.Variable iihVar,
								 Asset asset,
								 List<IMendixObject> buffer,
								 VariableStats stats) throws Exception {

		stats.variablesProcessed++;

		String varId   = iihVar.getObjectId();
		String varName = iihVar.getVariableName();
		String unit    = iihVar.getUnit();
		String dataType = iihVar.getDataType();

		if (varId == null || varId.isBlank()) {
			getLogger().warn("‚ö†Ô∏è Variable sans ObjectId ignor√©e ‚Äì asset " + asset.getIIH_Id());
			stats.variablesProcessed--; // on ne la compte pas
			return;
		}

		// === NEW : parse enums √† partir du nom (version plus permissive)
		MetricType metricType = MetricType.Custom;
		EnergyType energyType = EnergyType.None;

		// üêõ DEBUG - Log d√©taill√© du parsing des noms
		debugLog("üîç === DEBUG PARSING VARIABLE ===");
		debugLog("üîç Variable name: '" + varName + "'");

		if (varName != null && !varName.isBlank()) {
			String lowerName = varName.toLowerCase();
			debugLog("üîç Lowercase name: '" + lowerName + "'");
			
			// üÜï PARSING INTELLIGENT - G√©rer les patterns complexes
			ParseResult result = parseVariableName(lowerName);
			metricType = result.metricType;
			energyType = result.energyType;
			
			debugLog("üîç Final MetricType: " + metricType);
			debugLog("üîç Final EnergyType: " + energyType);
		} else {
			debugLog("üîç Variable name is null or blank");
		}
		debugLog("üîç === END DEBUG PARSING ===");

		/* === Recherche / upsert identique √† la logique d'origine === */
		Variable smartVar = null;
		boolean isNew = true;

		List<IMendixObject> found = Core.retrieveXPathQuery(ctx,
			"//Smart.Variable[IIH_Id='" + varId + "']");
		if (!found.isEmpty()) {
			smartVar = Variable.initialize(ctx, found.get(0));
			isNew = false;
		} else {
			smartVar = new Variable(ctx);
		}

		if (isNew) stats.variablesCreated++; else stats.variablesUpdated++;

		// === mapping des champs (ajout enums)
		smartVar.setIIH_Id(varId);
		smartVar.setName(varName != null ? varName : "");
		smartVar.setUnit(unit != null ? unit : "");
		smartVar.setDataType(dataType != null ? dataType : "");
		smartVar.setIsActive(true);
		smartVar.setLastSyncDate(new Date());
		smartVar.setVariable_Asset(asset);

		// === NEW : setters enum
		smartVar.setMetricType(metricType);
		smartVar.setEnergyType(energyType);

		// üÜï Taggage des flags √©nergie dans le cache
		AssetFlags flags = getAssetFlags(stats, asset);
		switch (energyType) {
			case Elec:
				flags.elec = true;
				break;
			case Gaz:
				flags.gaz = true;
				break;
			case Eau:
				flags.eau = true;
				break;
			case Air:
				flags.air = true;
				break;
			default:
				// no-op
				break;
		}

		buffer.add(smartVar.getMendixObject());

		if (buffer.size() >= BATCH_SIZE) {
			Core.commitWithoutEvents(ctx, buffer);
			stats.variablesCommitted += buffer.size();
			buffer.clear();
		}
	}

	/* === NEW : helpers enum ------------------------------------------------ */

	private MetricType mapMetric(String raw) {
		if (raw == null) return MetricType.Custom;
		switch (raw.toLowerCase()) {
			case "consommation":
			case "conso":
				return MetricType.Conso;
			case "ipe_kg":
			case "ipekg":
				return MetricType.IPE_kg;
			case "ipe":
				return MetricType.IPE;
			case "production":
			case "prod":
				return MetricType.Prod;
			case "production_kg":
			case "prod_kg":
				return MetricType.Prod_kg;
			default:
				return MetricType.Custom;
		}
	}

	private EnergyType mapEnergy(String raw) {
		if (raw == null) return EnergyType.None;
		
		// üêõ DEBUG - Log pour diagnostiquer le probl√®me de reconnaissance
		debugLog("üîç DEBUG mapEnergy - Raw input: '" + raw + "' (length: " + raw.length() + ")");
		
		// Normaliser et nettoyer la cha√Æne pour une comparaison robuste
		String normalized = raw.toLowerCase()
			.trim()
			.replace("√©", "e")
			.replace("√®", "e") 
			.replace("√™", "e")
			.replace("√†", "a")
			.replace("√ß", "c");
		
		debugLog("üîç DEBUG mapEnergy - Normalized: '" + normalized + "'");
		
		// √âlectricit√© : v√©rifier si la cha√Æne commence par "elec" ou "electricite"
		if (normalized.startsWith("elec") || normalized.startsWith("electricite")) {
			debugLog("‚úÖ DEBUG mapEnergy - Matched ELEC for: '" + raw + "'");
			return EnergyType.Elec;
		}
		
		// Gaz : v√©rifier si la cha√Æne commence par "gaz" ou "gas"
		if (normalized.startsWith("gaz") || normalized.startsWith("gas")) {
			debugLog("‚úÖ DEBUG mapEnergy - Matched GAZ for: '" + raw + "'");
			return EnergyType.Gaz;
		}
		
		// Eau : v√©rifier si la cha√Æne commence par "eau" ou "water"
		if (normalized.startsWith("eau") || normalized.startsWith("water")) {
			debugLog("‚úÖ DEBUG mapEnergy - Matched EAU for: '" + raw + "'");
			return EnergyType.Eau;
		}
		
		// Air : v√©rifier si la cha√Æne commence par "air"
		if (normalized.startsWith("air")) {
			debugLog("‚úÖ DEBUG mapEnergy - Matched AIR for: '" + raw + "'");
			return EnergyType.Air;
		}
		
		debugLog("‚ö†Ô∏è DEBUG mapEnergy - No match found for: '" + raw + "' - returning None");
		return EnergyType.None;
	}

	// üÜï PARSING INTELLIGENT des noms de variables
	private ParseResult parseVariableName(String lowerName) {
		debugLog("üîç parseVariableName - Input: '" + lowerName + "'");
		
		// === PATTERNS SP√âCIAUX - Priorit√© haute ===
		
		// 1. Production_kg ‚Üí MetricType.Prod_kg + EnergyType.None
		if (lowerName.startsWith("production_kg")) {
			debugLog("‚úÖ Matched pattern: Production_kg");
			return new ParseResult(MetricType.Prod_kg, EnergyType.None);
		}
		
		// 2. IPE_kg_xxx ‚Üí MetricType.IPE_kg + EnergyType correspondant
		if (lowerName.startsWith("ipe_kg_")) {
			String energyPart = lowerName.substring("ipe_kg_".length());
			debugLog("‚úÖ Matched pattern: IPE_kg_xxx, energyPart: '" + energyPart + "'");
			EnergyType energy = mapEnergy(energyPart);
			return new ParseResult(MetricType.IPE_kg, energy);
		}
		
		// 3. IPE_xxx ‚Üí MetricType.IPE + EnergyType correspondant  
		if (lowerName.startsWith("ipe_") && !lowerName.startsWith("ipe_kg_")) {
			String energyPart = lowerName.substring("ipe_".length());
			debugLog("‚úÖ Matched pattern: IPE_xxx, energyPart: '" + energyPart + "'");
			EnergyType energy = mapEnergy(energyPart);
			return new ParseResult(MetricType.IPE, energy);
		}
		
		// === PARSING G√âN√âRIQUE - Token splitting ===
		String[] tokens = lowerName.split("[_\\-\\.]+");
		
		debugLog("üîç Generic parsing - Tokens:");
		for (int i = 0; i < tokens.length; i++) {
			debugLog("   tokens[" + i + "] = '" + tokens[i] + "'");
		}
		
		String metricRaw = tokens.length > 0 ? tokens[0] : null;
		String energyRaw = tokens.length > 1 ? tokens[1] : null;
		
		debugLog("üîç Generic parsing - metricRaw: '" + metricRaw + "', energyRaw: '" + energyRaw + "'");
		
		// 4. Cas sp√©ciaux avec tokens multiples
		if (tokens.length >= 2) {
			// production_kg avec token split
			if ("production".equals(metricRaw) && "kg".equals(energyRaw)) {
				debugLog("‚úÖ Matched tokens: production + kg");
				return new ParseResult(MetricType.Prod_kg, EnergyType.None);
			}
			
			// ipe_kg avec token split  
			if ("ipe".equals(metricRaw) && "kg".equals(energyRaw) && tokens.length > 2) {
				String energyPart = tokens[2];
				debugLog("‚úÖ Matched tokens: ipe + kg + energy, energyPart: '" + energyPart + "'");
				EnergyType energy = mapEnergy(energyPart);
				return new ParseResult(MetricType.IPE_kg, energy);
			}
		}
		
		// 5. Parsing standard metric + energy
		MetricType metric = mapMetric(metricRaw);
		EnergyType energy = mapEnergy(energyRaw);
		
		debugLog("üîç Generic result - MetricType: " + metric + ", EnergyType: " + energy);
		return new ParseResult(metric, energy);
	}

	/* ------------- METTRE √Ä JOUR M√âTADONN√âES SYNC ------------- */
	private void updateSyncMetadata(IContext ctx, VariableStats stats, long durationMs, Exception error) throws Exception {
		
		if (syncMetadata != null) {
			syncMetadata.setVariablesProcessed(stats.variablesProcessed);
			syncMetadata.setVariablesCreated(stats.variablesCreated);
			syncMetadata.setVariablesUpdated(stats.variablesUpdated);
			
			// Mettre √† jour le statut si erreur
			if (error != null && syncMetadata.getSyncStatus() != SyncStatus.Error) {
				syncMetadata.setSyncStatus(SyncStatus.Error);
				syncMetadata.setErrorMessage(error.getMessage());
			}
			
			Core.commitWithoutEvents(ctx, syncMetadata.getMendixObject());
		}
	}

	/* ------------- LOGS FINAUX ------------- */
	private void logFinalVariableStats(VariableStats stats, long durationMs) {
		getLogger().info("=== STATISTIQUES VARIABLES FINALES ===");
		getLogger().info("‚è±Ô∏è Dur√©e totale: " + durationMs + "ms (" + String.format("%.2f", durationMs/1000.0) + "s)");
		getLogger().info("üè¢ Assets trait√©s: " + stats.assetsProcessed);
		getLogger().info("üìä Variables trait√©es: " + stats.variablesProcessed);
		getLogger().info("‚ú® Variables cr√©√©es: " + stats.variablesCreated);
		getLogger().info("üîÑ Variables mises √† jour: " + stats.variablesUpdated);
		getLogger().info("üíæ Variables committ√©es: " + stats.variablesCommitted);
		getLogger().info("üåê Appels API IIH: " + stats.iihApiCalls);
		getLogger().info("‚ùå Erreurs rencontr√©es: " + stats.errors);
		
		if (stats.variablesProcessed > 0) {
			double avgTimePerVar = (double) durationMs / stats.variablesProcessed;
			getLogger().info("üìà Temps moyen par variable: " + String.format("%.2f", avgTimePerVar) + "ms");
		}
		
		getLogger().info("=== FIN SYNC VARIABLES ===");
	}

	/* ------------- NETTOYAGE VARIABLES ------------- */
	private void cleanupVariables(IContext ctx) throws Exception {
		List<IMendixObject> variables = Core.retrieveXPathQuery(ctx, "//Smart.Variable");
		if (!variables.isEmpty()) {
			Core.deleteWithoutEvents(ctx, variables, false);
			getLogger().info("üóëÔ∏è  " + variables.size() + " Variables supprim√©es");
		}
	}

	// üÜï Mise √† jour batch des flags √©nergie sur les assets Smart
	private void batchUpdateAssetEnergyFlags(IContext ctx, VariableStats stats) throws Exception {
		List<IMendixObject> toCommit = new ArrayList<>();

		for (Map.Entry<String, AssetFlags> entry : stats.assetFlags.entrySet()) {
			String iihId      = entry.getKey();
			AssetFlags flags  = entry.getValue();

			List<IMendixObject> found = Core.retrieveXPathQuery(ctx,
				"//Smart.Asset[IIH_Id='" + iihId + "']");
			if (found.isEmpty()) continue;

			Asset a = Asset.initialize(ctx, found.get(0));
			boolean dirty = false;

			if (flags.elec && !Boolean.TRUE.equals(a.getisElec())) { a.setisElec(true); dirty = true; }
			if (flags.gaz  && !Boolean.TRUE.equals(a.getisGaz()))  { a.setisGaz(true);  dirty = true; }
			if (flags.eau  && !Boolean.TRUE.equals(a.getisEau()))  { a.setisEau(true);  dirty = true; }
			if (flags.air  && !Boolean.TRUE.equals(a.getisAir()))  { a.setisAir(true);  dirty = true; }

			if (dirty) toCommit.add(a.getMendixObject());
		}

		if (!toCommit.isEmpty()) {
			Core.commitWithoutEvents(ctx, toCommit);
			getLogger().info("‚ö°Ô∏è Asset energy flags mis √† jour pour " + toCommit.size() + " assets");
		} else {
			getLogger().info("üëå Aucun changement de flags √©nergie √† committer");
		}
	}
	// END EXTRA CODE
}
