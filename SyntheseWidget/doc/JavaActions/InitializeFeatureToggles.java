// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., √©, √∂, √†, etc. are supported in comments.

package smart.actions;

import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;
import com.mendix.logging.ILogNode;
import smart.proxies.FeatureToggle;
import smart.proxies.Features;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class InitializeFeatureToggles extends CustomJavaAction<java.lang.Void>
{
	public InitializeFeatureToggles(IContext context)
	{
		super(context);
	}

	@java.lang.Override
	public java.lang.Void executeAction() throws Exception
	{
		// BEGIN USER CODE
        IContext ctx = getContext();
        
        getLogger().info("=== INITIALISATION FEATURE TOGGLES ===");
        getLogger().info("üéØ Syst√®me global");

        InitializationStats stats = new InitializationStats();
        long startTime = System.currentTimeMillis();

        try {
            // üöÄ INITIALISATION AUTOMATIQUE : Traiter toutes les features de l'√©num√©ration
            getLogger().info("üîÑ Initialisation automatique de toutes les features...");
            
            for (Features feature : Features.values()) {
                // D√©finir un comportement par d√©faut pour chaque feature
                boolean defaultEnabled = getDefaultEnabledState(feature);
                String description = "Auto-init " + feature.toString();

                // Appeler la fonction d'initialisation
                initializeFeature(ctx, feature, defaultEnabled, description, stats);
            }

            // üßπ NETTOYAGE : Supprimer les lignes obsol√®tes
            cleanupObsoleteToggles(ctx, stats);

            // Logs finaux
            long duration = System.currentTimeMillis() - startTime;
            logFinalStats(stats, duration);

            return null; // Void return type

        } catch (Exception e) {
            long duration = System.currentTimeMillis() - startTime;
            getLogger().error("üí• Erreur critique initialisation Feature Toggles: " + e.getMessage(), e);
            logFinalStats(stats, duration);
            throw e;
        }
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "InitializeFeatureToggles";
	}

	// BEGIN EXTRA CODE
    /* ==== LOGGER ==== */
    private static final ILogNode LOG = Core.getLogger("FeatureToggleInit");
    
    private ILogNode getLogger() {
        return LOG;
    }

    /* ==== STATISTIQUES D'INITIALISATION ==== */
    private static class InitializationStats {
        int featuresProcessed = 0;
        int togglesCreated = 0;
        int togglesUpdated = 0;
        int togglesSkipped = 0;
        int togglesDeleted = 0; // üÜï Nouveau compteur pour les suppressions
        int errors = 0;
    }

    /* ==== NETTOYAGE DES LIGNES OBSOL√àTES ==== */
    private void cleanupObsoleteToggles(IContext ctx, InitializationStats stats) throws Exception {
        getLogger().info("üßπ D√©but du nettoyage des Feature Toggles obsol√®tes...");
        
        try {
            // R√©cup√©rer tous les literals actuels de l'√©num√©ration Features
            Set<String> enumLiterals = getCurrentEnumLiterals();
            getLogger().debug("üìã Literals actuels de l'√©num√©ration: " + enumLiterals);
            
            // R√©cup√©rer tous les FeatureToggles existants dans la BDD
            List<IMendixObject> allToggles = Core.retrieveXPathQuery(ctx, "//Smart.FeatureToggle");
            getLogger().debug("üîç " + allToggles.size() + " Feature Toggles trouv√©s en BDD");
            
            int deletedCount = 0;
            
            for (IMendixObject toggle : allToggles) {
                String featureName = (String) toggle.getValue(ctx, "FeatureName");
                
                if (featureName != null && !enumLiterals.contains(featureName)) {
                    // Ce FeatureToggle correspond √† un literal qui n'existe plus
                    getLogger().info("üóëÔ∏è Suppression Feature Toggle obsol√®te: " + featureName);
                    Core.delete(ctx, toggle);
                    deletedCount++;
                }
            }
            
            stats.togglesDeleted = deletedCount;
            getLogger().info("‚úÖ Nettoyage termin√©: " + deletedCount + " Feature Toggles obsol√®tes supprim√©s");
            
        } catch (Exception e) {
            stats.errors++;
            getLogger().error("‚ùå Erreur lors du nettoyage des Feature Toggles obsol√®tes: " + e.getMessage(), e);
            throw e;
        }
    }
    
    /* ==== R√âCUP√âRATION DES LITERALS ACTUELS ==== */
    private Set<String> getCurrentEnumLiterals() {
        Set<String> literals = new java.util.HashSet<>();
        
        // ‚úÖ AUTOMATISATION : R√©cup√©ration dynamique de tous les literals
        for (Features feature : Features.values()) {
            literals.add(feature.toString());
        }
        
        getLogger().debug("üìã Literals r√©cup√©r√©s dynamiquement: " + literals);
        return literals;
    }

    /* ==== D√âFINITION DES VALEURS PAR D√âFAUT ==== */
    private boolean getDefaultEnabledState(Features feature) {
        // D√©finir les valeurs par d√©faut pour chaque feature
        switch (feature) {
            case Double_IPE:
                return false; // Calcul IPE alternatif d√©sactiv√© par d√©faut
            case Rapport:
                return true;  // Rapports activ√©s par d√©faut
            default:
                // Pour toute nouvelle feature, d√©sactiv√©e par d√©faut (principe de s√©curit√©)
                getLogger().info("‚ö†Ô∏è Nouvelle feature d√©tect√©e: " + feature.toString() + " - d√©sactiv√©e par d√©faut");
                return false;
        }
    }

    /* ==== INITIALISATION D'UNE FEATURE SP√âCIFIQUE ==== */
    private void initializeFeature(IContext ctx, Features feature, 
                                 boolean defaultEnabled, String description, InitializationStats stats) throws Exception {
        
        stats.featuresProcessed++;
        
        getLogger().debug("üîç Traitement feature: " + feature.toString());

        // V√©rifier si le toggle existe d√©j√† pour cette feature (par valeur d'√©num, pas caption)
        String xpath = String.format(
            "//Smart.FeatureToggle[FeatureName='%s']",
            feature.toString() // Utilise la valeur d'√©num (ex: "Double_IPE"), pas le caption
        );
        
        List<IMendixObject> existing = Core.retrieveXPathQuery(ctx, xpath);

        if (existing.isEmpty()) {
            // Cr√©er un nouveau FeatureToggle (create-missing-only)
            FeatureToggle newToggle = new FeatureToggle(ctx);
            
            // D√©finir les propri√©t√©s avec type safety complet
            newToggle.setFeatureName(feature);  // Type-safe assignment
            newToggle.setIsEnabled(defaultEnabled);
            newToggle.setConfigurationValue(""); // Configuration vide pour syst√®me global
            
            Core.commit(ctx, newToggle.getMendixObject());
            stats.togglesCreated++;
            
            getLogger().info("‚ú® Feature Toggle cr√©√©: " + feature.toString() + " (enabled: " + defaultEnabled + ")");
            
        } else {
            // NE PAS TOUCHER IsEnabled ni ConfigurationValue si la ligne existe d√©j√†
            // L'administrateur a peut-√™tre modifi√© ces valeurs
            stats.togglesSkipped++;
            
            getLogger().debug("‚è≠Ô∏è Feature Toggle existant ignor√©: " + feature.toString() + " (valeurs pr√©serv√©es)");
        }
    }

    /* ==== LOGS FINAUX ==== */
    private void logFinalStats(InitializationStats stats, long durationMs) {
        getLogger().info("=== STATISTIQUES INITIALISATION FINALES ===");
        getLogger().info("‚è±Ô∏è Dur√©e totale: " + durationMs + "ms (" + String.format("%.2f", durationMs/1000.0) + "s)");
        getLogger().info("üìä Features trait√©es: " + stats.featuresProcessed);
        getLogger().info("‚ú® Feature Toggles cr√©√©s: " + stats.togglesCreated);
        getLogger().info("üîÑ Feature Toggles mis √† jour: " + stats.togglesUpdated);
        getLogger().info("‚è≠Ô∏è Feature Toggles ignor√©s: " + stats.togglesSkipped);
        getLogger().info("üóëÔ∏è Feature Toggles supprim√©s: " + stats.togglesDeleted); // üÜï Nouveau log
        getLogger().info("‚ùå Erreurs rencontr√©es: " + stats.errors);
        
        if (stats.featuresProcessed > 0) {
            double avgTimePerFeature = (double) durationMs / stats.featuresProcessed;
            getLogger().info("üìà Temps moyen par feature: " + String.format("%.2f", avgTimePerFeature) + "ms");
        }
        
        getLogger().info("=== FIN INITIALISATION FEATURE TOGGLES ===");
    }
	// END EXTRA CODE
}
