// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package smart.actions;

import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.stream.Collectors;
import com.mendix.core.Core;
import smart.proxies.Level;
import smart.proxies.Asset;
import smart.proxies.Variable;
import smart.proxies.DateRange;
import smart.proxies.EnergyType;
import smart.proxies.MetricType;
import smart.proxies.CalculationTrend;
import iihessentialsconnector.proxies.ENUM_Boolean;
import iihessentialsconnector.proxies.CalculateRequest;
import iihessentialsconnector.proxies.DataSources;
import iihessentialsconnector.proxies.DataSource;
import iihessentialsconnector.proxies.ENUM_Calculate_Type;
import iihessentialsconnector.proxies.ENUM_DataSource_Aggregation;
import iihessentialsconnector.proxies.CalculateMessage;
import iihessentialsconnector.proxies.Calculation;
import iihessentialsconnector.proxies.CalculationValue;
import iihessentialsconnector.proxies.HttpError;
import iihessentialsconnector.proxies.microflows.Microflows;
import java.math.BigDecimal;
import com.mendix.systemwideinterfaces.core.UserAction;

public class CalculateLevelAggregation extends CustomJavaAction<IMendixObject>
{
	/** @deprecated use DateRange.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __DateRange;
	private final smart.proxies.DateRange DateRange;
	/** @deprecated use Level.getMendixObject() instead. */
	@java.lang.Deprecated(forRemoval = true)
	private final IMendixObject __Level;
	private final smart.proxies.Level Level;
	private final smart.proxies.EnergyType EnergyType;
	private final smart.proxies.MetricType MetricType;
	private final smart.proxies.AggregationMode AggregationMode;
	private final iihessentialsconnector.proxies.ENUM_Boolean UsePrecalculatedData;

	public CalculateLevelAggregation(
		IContext context,
		IMendixObject _dateRange,
		IMendixObject _level,
		java.lang.String _energyType,
		java.lang.String _metricType,
		java.lang.String _aggregationMode,
		java.lang.String _usePrecalculatedData
	)
	{
		super(context);
		this.__DateRange = _dateRange;
		this.DateRange = _dateRange == null ? null : smart.proxies.DateRange.initialize(getContext(), _dateRange);
		this.__Level = _level;
		this.Level = _level == null ? null : smart.proxies.Level.initialize(getContext(), _level);
		this.EnergyType = _energyType == null ? null : smart.proxies.EnergyType.valueOf(_energyType);
		this.MetricType = _metricType == null ? null : smart.proxies.MetricType.valueOf(_metricType);
		this.AggregationMode = _aggregationMode == null ? null : smart.proxies.AggregationMode.valueOf(_aggregationMode);
		this.UsePrecalculatedData = _usePrecalculatedData == null ? null : iihessentialsconnector.proxies.ENUM_Boolean.valueOf(_usePrecalculatedData);
	}

	@java.lang.Override
	public IMendixObject executeAction() throws Exception
	{
		// BEGIN USER CODE
		IContext context = getContext();

		// Check if required parameters are provided
		if (this.Level == null) {
			Core.getLogger("CalculateLevelAggregation").error("Level parameter is null - cannot execute aggregation");
			throw new com.mendix.systemwideinterfaces.MendixRuntimeException("Level parameter is required for CalculateLevelAggregation");
		}
		
		if (this.EnergyType == null) {
			Core.getLogger("CalculateLevelAggregation").error("EnergyType parameter is null - cannot execute aggregation");
			throw new com.mendix.systemwideinterfaces.MendixRuntimeException("EnergyType parameter is required for CalculateLevelAggregation");
		}
		
		if (this.MetricType == null) {
			Core.getLogger("CalculateLevelAggregation").error("MetricType parameter is null - cannot execute aggregation");
			throw new com.mendix.systemwideinterfaces.MendixRuntimeException("MetricType parameter is required for CalculateLevelAggregation");
		}

		// 1. Get all assets for the given level
		List<IMendixObject> assetObjects = Core.retrieveByPath(context, this.Level.getMendixObject(), "Smart.Asset_Level");
		
		if (assetObjects.isEmpty()) {
			Core.getLogger("CalculateLevelAggregation").warn("No assets found for level: " + this.Level.getName());
			
			// Only reset the specific metric/energy combination we're updating
			if (this.MetricType == MetricType.Conso) {
				switch (this.EnergyType) {
					case Elec: this.Level.setConsoTotalElec(BigDecimal.ZERO); break;
					case Gaz: this.Level.setConsoTotalGaz(BigDecimal.ZERO); break;
					case Eau: this.Level.setConsoTotalEau(BigDecimal.ZERO); break;
					case Air: this.Level.setConsoTotalAir(BigDecimal.ZERO); break;
				}
			} else if (this.MetricType == MetricType.IPE) {
				switch (this.EnergyType) {
					case Elec: this.Level.setIPETotalElec(BigDecimal.ZERO); break;
					case Gaz: this.Level.setIPETotalGaz(BigDecimal.ZERO); break;
					case Eau: this.Level.setIPETotalEau(BigDecimal.ZERO); break;
					case Air: this.Level.setIPETotalAir(BigDecimal.ZERO); break;
				}
			}
			
			Core.commit(context, this.Level.getMendixObject());
			return this.Level.getMendixObject();
		}

		// 2. Collect all Conso and IPE variables for these assets
		Map<String, Variable> variableMap = new HashMap<>();
		int totalVariablesFound = 0;
		int matchingVariables = 0;
		
		for (IMendixObject assetObj : assetObjects) {
			List<Variable> variables = Variable.load(context, "[Smart.Variable_Asset = " + assetObj.getId().toLong() + "]");
			totalVariablesFound += variables.size();
			
			for (Variable v : variables) {
				// Filter by the specific MetricType and EnergyType passed as parameters
				if (v.getMetricType() == this.MetricType && v.getEnergyType() == this.EnergyType) {
					variableMap.put(v.getIIH_Id(), v);
					matchingVariables++;

				}
			}
		}



		if (variableMap.isEmpty()) {
			Core.getLogger("CalculateLevelAggregation").warn("No variables found matching criteria - Level: " + this.Level.getName() + 
				", MetricType: " + this.MetricType + ", EnergyType: " + this.EnergyType);
			
			// Only reset the specific metric/energy combination we're updating
			if (this.MetricType == MetricType.Conso) {
				switch (this.EnergyType) {
					case Elec: this.Level.setConsoTotalElec(BigDecimal.ZERO); break;
					case Gaz: this.Level.setConsoTotalGaz(BigDecimal.ZERO); break;
					case Eau: this.Level.setConsoTotalEau(BigDecimal.ZERO); break;
					case Air: this.Level.setConsoTotalAir(BigDecimal.ZERO); break;
				}
			} else if (this.MetricType == MetricType.IPE) {
				switch (this.EnergyType) {
					case Elec: this.Level.setIPETotalElec(BigDecimal.ZERO); break;
					case Gaz: this.Level.setIPETotalGaz(BigDecimal.ZERO); break;
					case Eau: this.Level.setIPETotalEau(BigDecimal.ZERO); break;
					case Air: this.Level.setIPETotalAir(BigDecimal.ZERO); break;
				}
			}
			
			this.Level.setAssetCount(assetObjects.size());
			Core.commit(context, this.Level.getMendixObject());
			return this.Level.getMendixObject();
		}

		// 3. Prepare and execute the single API call

		
		CalculationTrend emptyTrend = new CalculationTrend(context); // Create empty trend to satisfy method signature
		CalculateRequest calculateRequest = smart.proxies.microflows.Microflows.calculationTimeRange(context, this.DateRange, emptyTrend);
		DataSources dataSourceWrapper = new DataSources(context);
		dataSourceWrapper.setCalculateRequest_DataSources(calculateRequest);
		
		iihessentialsconnector.proxies.ENUM_DataSource_Aggregation aggregation = this.AggregationMode != null ? 
			convertAggregationMode(this.AggregationMode) : 
			iihessentialsconnector.proxies.ENUM_DataSource_Aggregation.Sum;
		

		
		for (Variable v : variableMap.values()) {
			DataSource ds = new DataSource(context);
			ds.set_id(v.getIIH_Id());
			ds.set_type(ENUM_Calculate_Type.Variable);
			ds.setAggregation(aggregation);
			ds.setDataSource_DataSources(dataSourceWrapper);

		}
		CalculateMessage calculateMessage = Microflows.pOST_v1_8_Calculate_Trend(context, calculateRequest, null, null, this.UsePrecalculatedData);
		
		HttpError error = calculateMessage.getHttpError_IIHMessage(context);
		if (error != null) {
			Core.getLogger("CalculateLevelAggregation").error("IIH API Error: " + error.getMessage());
			return null;
		}
		


		// 4. Process results and aggregate
		Map<String, BigDecimal> aggregatedValues = new HashMap<>();
		List<IMendixObject> calculationObjects = Core.retrieveByPath(context, calculateMessage.getMendixObject(), "IIHEssentialsConnector.Calculation_CalculateMessage");
		


		for (IMendixObject calcObj : calculationObjects) {
			Calculation calculation = Calculation.initialize(context, calcObj);
			DataSource ds = calculation.getDataSource_Calculation(context);
			
			if (ds != null) {
				// Get CalculationValue objects (like in CalculateSingleMetric)
				List<IMendixObject> valueIMendixObjectList = Core.retrieveByPath(context, 
					calculation.getMendixObject(), "IIHEssentialsConnector.CalculationValue_Calculation");
				

				
				for (IMendixObject valueIMendixObject : valueIMendixObjectList) {
					CalculationValue calcValue = CalculationValue.initialize(context, valueIMendixObject);
					
					if (calcValue.getValue() != null) {
						Variable originalVar = variableMap.get(ds.get_id());
						if (originalVar != null) {
							String key = originalVar.getMetricType().toString() + "_" + originalVar.getEnergyType().toString();
							BigDecimal currentValue = calcValue.getValue();
							aggregatedValues.merge(key, currentValue, BigDecimal::add);
							

						} else {
							Core.getLogger("CalculateLevelAggregation").warn("Variable not found in map for DataSource ID: " + ds.get_id());
						}
					} else {

					}
				}
			} else {
				Core.getLogger("CalculateLevelAggregation").warn("DataSource is null for calculation");
			}
		}
		

		
		// 5. Update and commit Level object
		updateLevelAttributes(this.Level, aggregatedValues);
		this.Level.setAssetCount(assetObjects.size());
		
		// Force commit with events to ensure UI refresh
		Core.commit(context, this.Level.getMendixObject());
		


		return this.Level.getMendixObject();
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "CalculateLevelAggregation";
	}

	// BEGIN EXTRA CODE
	private void initializeLevelToZero(Level level) {
		level.setConsoTotalElec(BigDecimal.ZERO);
		level.setConsoTotalGaz(BigDecimal.ZERO);
		level.setConsoTotalEau(BigDecimal.ZERO);
		level.setConsoTotalAir(BigDecimal.ZERO);
		level.setIPETotalElec(BigDecimal.ZERO);
		level.setIPETotalGaz(BigDecimal.ZERO);
		level.setIPETotalEau(BigDecimal.ZERO);
		level.setIPETotalAir(BigDecimal.ZERO);
		// Assuming you add a ProdTotal attribute to Level as well
		// level.setProdTotal(BigDecimal.ZERO);
	}
	
	private void updateLevelAttributes(Level level, Map<String, BigDecimal> aggregatedValues) {

		
		// Only reset the specific metric/energy combination we're updating
		if (this.MetricType == MetricType.Conso) {
			switch (this.EnergyType) {
				case Elec: level.setConsoTotalElec(BigDecimal.ZERO); break;
				case Gaz: level.setConsoTotalGaz(BigDecimal.ZERO); break;
				case Eau: level.setConsoTotalEau(BigDecimal.ZERO); break;
				case Air: level.setConsoTotalAir(BigDecimal.ZERO); break;
			}
		} else if (this.MetricType == MetricType.IPE) {
			switch (this.EnergyType) {
				case Elec: level.setIPETotalElec(BigDecimal.ZERO); break;
				case Gaz: level.setIPETotalGaz(BigDecimal.ZERO); break;
				case Eau: level.setIPETotalEau(BigDecimal.ZERO); break;
				case Air: level.setIPETotalAir(BigDecimal.ZERO); break;
			}
		}
		
		for (Map.Entry<String, BigDecimal> entry : aggregatedValues.entrySet()) {
			String[] parts = entry.getKey().split("_");
			MetricType metric = MetricType.valueOf(parts[0]);
			EnergyType energy = EnergyType.valueOf(parts[1]);
			BigDecimal value = entry.getValue();
			

			
			if (metric == MetricType.Conso) {
				switch (energy) {
					case Elec: level.setConsoTotalElec(value); break;
					case Gaz: level.setConsoTotalGaz(value); break;
					case Eau: level.setConsoTotalEau(value); break;
					case Air: level.setConsoTotalAir(value); break;
				}
			} else if (metric == MetricType.IPE) {
				switch (energy) {
					case Elec: level.setIPETotalElec(value); break;
					case Gaz: level.setIPETotalGaz(value); break;
					case Eau: level.setIPETotalEau(value); break;
					case Air: level.setIPETotalAir(value); break;
				}
			}
		}
		

	}
	
	/**
	 * Convert AggregationMode enum to IIH DataSource Aggregation enum
	 */
	private iihessentialsconnector.proxies.ENUM_DataSource_Aggregation convertAggregationMode(smart.proxies.AggregationMode mode) {
		switch (mode) {
			case SUM:
				return iihessentialsconnector.proxies.ENUM_DataSource_Aggregation.Sum;
			case AVG:
				return iihessentialsconnector.proxies.ENUM_DataSource_Aggregation.Average;
			case MIN:
				return iihessentialsconnector.proxies.ENUM_DataSource_Aggregation.Min;
			case MAX:
				return iihessentialsconnector.proxies.ENUM_DataSource_Aggregation.Max;
			default:
				return iihessentialsconnector.proxies.ENUM_DataSource_Aggregation.Sum;
		}
	}
	// END EXTRA CODE
}
