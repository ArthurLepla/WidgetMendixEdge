// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., √©, √∂, √†, etc. are supported in comments.

package smart.actions;

import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.core.Core;
import com.mendix.logging.ILogNode;
import smart.proxies.Asset;             // entit√© persistante
import smart.proxies.Level;
import smart.proxies.SyncMetadata;
import smart.proxies.SyncStatus;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.Date;
import com.mendix.systemwideinterfaces.core.UserAction;

public class ProcessIIHAssetTree extends CustomJavaAction<IMendixObject>
{
	private final java.lang.Long BATCH_SIZE;
	private final java.lang.Boolean isScheduledMode;
	private final java.util.Date lastSyncTimestamp;
	private final java.lang.Boolean testLocal;

	public ProcessIIHAssetTree(
		IContext context,
		java.lang.Long _bATCH_SIZE,
		java.lang.Boolean _isScheduledMode,
		java.util.Date _lastSyncTimestamp,
		java.lang.Boolean _testLocal
	)
	{
		super(context);
		this.BATCH_SIZE = _bATCH_SIZE;
		this.isScheduledMode = _isScheduledMode;
		this.lastSyncTimestamp = _lastSyncTimestamp;
		this.testLocal = _testLocal;
	}

	@java.lang.Override
	public IMendixObject executeAction() throws Exception
	{
		// BEGIN USER CODE
		IContext ctx = getContext();
		
		// === R√âCUP√âRATION DES ASSETS VIA MICROFLOW ===
		List<iihessentialsconnector.proxies.Asset> allAssets = getAllAssetsFromMicroflow(ctx);
		
		if (allAssets.isEmpty()) {
			getLogger().warn("‚ö†Ô∏è Aucun asset r√©cup√©r√© depuis IIH");
			return null;
		}
		
		getLogger().info("üì• " + allAssets.size() + " assets r√©cup√©r√©s depuis IIH");
		
		// === NETTOYAGE DES DONN√âES AVANT SYNCHRO ===
		cleanupAssetsAndLevels(ctx);
		getLogger().info("üßπ Nettoyage initial : anciens Assets et Levels supprim√©s");
		
		List<IMendixObject> buffer = new ArrayList<>();
		
		// Cr√©er m√©tadonn√©es de sync
		SyncMetadata syncMeta = new SyncMetadata(ctx);
		syncMeta.setSyncStartTime(new Date());
		syncMeta.setIsIncrementalSync(lastSyncTimestamp != null);
		syncMeta.setSyncStatus(SyncStatus.Running);
		forceClientRefresh(ctx, syncMeta.getMendixObject());
		Core.getLogger("IIHSync").info("üîÑ M√©tadonn√©es de sync cr√©√©es et refresh client forc√©");

		// Statistiques et optimisations
		ProcessingStats stats = new ProcessingStats();
		Set<String> visitedIds = new HashSet<>();
		Map<Integer, IMendixObject> levelCache = new HashMap<>(); // Cache des niveaux
		Map<String, iihessentialsconnector.proxies.Asset> assetMap = new HashMap<>(); // Map pour acc√®s rapide
		
		// Construire la map des assets pour acc√®s rapide
		for (iihessentialsconnector.proxies.Asset asset : allAssets) {
			if (asset.getObjectId() != null) {
				assetMap.put(asset.getObjectId(), asset);
			}
		}
		
		int maxDepth = (isScheduledMode != null && isScheduledMode) ? 100 : 50; // Adapt√© selon le mode
		
		if (isScheduledMode != null && isScheduledMode) {
			getLogger().info("=== SYNCHRONISATION BATCH IIH ===");
		} else {
			getLogger().info("=== SYNCHRONISATION TEMPS R√âEL IIH ===");
		}
		getLogger().info("‚öôÔ∏è Mode: " + ((isScheduledMode != null && isScheduledMode) ? "Batch" : "Temps r√©el"));
		getLogger().info("‚öôÔ∏è Batch size: " + BATCH_SIZE + ", Max depth: " + maxDepth);

		long startTime = System.currentTimeMillis();

		try {
			// Identifier les assets racines (ceux sans parent ou avec parentId = "0")
			List<iihessentialsconnector.proxies.Asset> rootAssets = new ArrayList<>();
			for (iihessentialsconnector.proxies.Asset asset : allAssets) {
				String parentId = asset.getParentId();
				if (parentId == null || parentId.trim().isEmpty() || "0".equals(parentId)) {
					// Exclure l'asset avec IIH_Id = "0"
					if (!"0".equals(asset.getObjectId())) {
						rootAssets.add(asset);
					}
				}
			}
			
			getLogger().info("üå≥ " + rootAssets.size() + " assets racines identifi√©s");
			
			// Traiter chaque asset racine
			for (iihessentialsconnector.proxies.Asset rootAsset : rootAssets) {
				processNodeWithAllAssets(ctx, rootAsset, null, 0, buffer, 
										visitedIds, levelCache, maxDepth, stats, syncMeta, assetMap);
			}

			// Commit final avec refresh client
			if (!buffer.isEmpty()) {
				forceClientRefresh(ctx, buffer); // Refresh client pour tous les assets
				stats.assetsCommitted += buffer.size();
				getLogger().info("üì¶ Final commit: " + buffer.size() + " objets (refresh client forc√©)");
			}

			// Finaliser les m√©tadonn√©es
			long duration = System.currentTimeMillis() - startTime;
			finalizeSyncMetadata(syncMeta, stats, duration, null);

			// Supprimer le root asset (IIH_Id = "0") apr√®s la synchronisation
			cleanupRootAsset(ctx);

		} catch (Exception e) {
			getLogger().error("üí• Erreur critique lors du traitement: " + e.getMessage(), e);
			long duration = System.currentTimeMillis() - startTime;
			finalizeSyncMetadata(syncMeta, stats, duration, e);
			throw e; // Re-lancer pour que l'appelant soit inform√©
		}

		// Statistiques finales
		long duration = System.currentTimeMillis() - startTime;
		logFinalStats(stats, duration);
		
		return syncMeta.getMendixObject();
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "ProcessIIHAssetTree";
	}

	// BEGIN EXTRA CODE
	/* ==== LOGGER ==== */
	private static final ILogNode LOG = Core.getLogger("IIHSync");

	private ILogNode getLogger() {
		return LOG;
	}

	/* ==== R√âCUP√âRATION DES ASSETS VIA MICROFLOW ==== */
	private List<iihessentialsconnector.proxies.Asset> getAllAssetsFromMicroflow(IContext ctx) throws Exception {
		List<iihessentialsconnector.proxies.Asset> assets = new ArrayList<>();
		
		try {
			// D√©terminer l'URL IIH en fonction du param√®tre testLocal
			String iihUrl = (testLocal != null && testLocal) ? "http://localhost:4203" : null;
			
			// Appeler le microflow GET_v1_8_Assets_All
			IMendixObject result = Core.microflowCall("IIHEssentialsConnector.GET_v1_8_Assets_All")
				.withParam("IIHEssentialsURL_RequiredIfExternal", iihUrl)
				.withParam("DecryptedDeviceToken_RequiredIfExternal", null) // empty
				.withParam("AssetList_Optional", null) // empty
				.withParam("IncludeChildren_Optional", null) // empty
				.withParam("IncludeBreadcrumb_Optional", null) // empty
				.execute(ctx);
			
			if (result != null) {
				// R√©cup√©rer tous les assets li√©s au message
				List<IMendixObject> assetObjects = Core.retrieveByPath(ctx, result, "IIHEssentialsConnector.Asset_AssetsMessage");
				
				for (IMendixObject assetObj : assetObjects) {
					iihessentialsconnector.proxies.Asset asset = 
						iihessentialsconnector.proxies.Asset.initialize(ctx, assetObj);
					assets.add(asset);
				}
				
				getLogger().info("‚úÖ Microflow GET_v1_8_Assets_All ex√©cut√© avec succ√®s");
			}
			
		} catch (Exception e) {
			getLogger().error("‚ùå Erreur lors de l'appel du microflow GET_v1_8_Assets_All: " + e.getMessage(), e);
			throw e;
		}
		
		return assets;
	}

	/* ==== TRAITEMENT AVEC TOUS LES ASSETS EN M√âMOIRE ==== */
	private void processNodeWithAllAssets(IContext ctx,
									     iihessentialsconnector.proxies.Asset iihAsset,
									     smart.proxies.Asset persistentParent,
									     int depthLevel,
									     List<IMendixObject> buf,
									     Set<String> visitedIds,
									     Map<Integer, IMendixObject> levelCache,
									     int maxDepth,
									     ProcessingStats stats,
									     SyncMetadata syncMeta,
									     Map<String, iihessentialsconnector.proxies.Asset> assetMap) throws Exception {

		String extId = iihAsset.getObjectId();
		String name = iihAsset.getName();
		Boolean hasChildren = iihAsset.getHasChildren();

		// Calcul du niveau absolu depuis le parent Mendix
		int absoluteLevel = calculateLevelFromParent(ctx, persistentParent);

		// Logs r√©duits en production (seulement niveaux importants)
		if (absoluteLevel <= 3 || absoluteLevel % 5 == 0) {
			getLogger().info("üîÑ [L" + absoluteLevel + "] " + extId + " (" + name + ")");
		}

		stats.assetsProcessed++;

		// Progress reporting en mode batch
		if (isScheduledMode != null && isScheduledMode && stats.assetsProcessed % 50 == 0) {
			syncMeta.setAssetsProcessed(stats.assetsProcessed);
			syncMeta.setAssetsCreated(stats.assetsCreated);
			syncMeta.setAssetsUpdated(stats.assetsUpdated);
			forceClientRefresh(ctx, syncMeta.getMendixObject());
			getLogger().info("üìä Batch progress: " + stats.assetsProcessed + " assets trait√©s (refresh client forc√©)");
		}

		// ===== PROTECTIONS =====
		if (extId == null || extId.trim().isEmpty()) {
			stats.assetsSkipped++;
			return;
		}

		if (visitedIds.contains(extId)) {
			stats.cyclesDetected++;
			if (absoluteLevel <= 5) {
				getLogger().debug("üîÑ Cycle √©vit√©: " + extId);
			}
			return;
		}

		if (depthLevel > maxDepth) {
			stats.maxDepthReached++;
			getLogger().warn("‚ö†Ô∏è Profondeur max atteinte: " + depthLevel);
			return;
		}

		visitedIds.add(extId);

		try {
			// ---- UPSERT OPTIMIS√â ----
			List<IMendixObject> found = Core.retrieveXPathQuery(ctx, "//Smart.Asset[IIH_Id='" + extId + "']");
			Asset tgt = found.isEmpty() ? new Asset(ctx) : Asset.initialize(ctx, found.get(0));

			boolean isNew = found.isEmpty();
			if (isNew) {
				stats.assetsCreated++;
			} else {
				stats.assetsUpdated++;
			}

			// Mise √† jour des donn√©es
			tgt.setIIH_Id(extId);
			tgt.setNom(name != null ? name : "");
			tgt.setHasChildren(hasChildren != null ? hasChildren : false);

			// Parent
			if (persistentParent != null) {
				tgt.setAsset_Parent(persistentParent);
			}

			// Niveau avec cache
			tgt.setAsset_Level(Level.initialize(ctx, getOrCreateLevelCached(ctx, absoluteLevel, levelCache, stats)));

			// Buffer optimis√©
			buf.add(tgt.getMendixObject());
			if (buf.size() >= BATCH_SIZE) {
				forceClientRefresh(ctx, buf);
				stats.assetsCommitted += buf.size();
				if (stats.assetsCommitted % (BATCH_SIZE * 5) == 0) {
					getLogger().info("üìä Progression: " + stats.assetsCommitted + " objets committ√©s (refresh client forc√©)");
				}
				buf.clear();
			}

			// ---- R√âCURSION SUR LES ENFANTS (depuis la map) ----
			if (hasChildren != null && hasChildren && depthLevel < maxDepth) {
				// Chercher les enfants dans la map
				List<iihessentialsconnector.proxies.Asset> children = new ArrayList<>();
				
				for (iihessentialsconnector.proxies.Asset potentialChild : assetMap.values()) {
					if (extId.equals(potentialChild.getParentId())) {
						children.add(potentialChild);
					}
				}
				
				if (!children.isEmpty()) {
					getLogger().debug("üë∂ " + children.size() + " enfants trouv√©s pour " + extId);
					
					for (iihessentialsconnector.proxies.Asset kidAsset : children) {
						String kidId = kidAsset.getObjectId();
						
						if (kidId != null && !visitedIds.contains(kidId) && !"0".equals(kidId)) {
							processNodeWithAllAssets(ctx, kidAsset, tgt, depthLevel + 1, buf, 
													visitedIds, levelCache, maxDepth, stats, syncMeta, assetMap);
						} else {
							stats.assetsSkipped++;
						}
					}
				}
			}

		} catch (Exception e) {
			stats.errors++;
			getLogger().error("‚ùå Erreur traitement " + extId + ": " + e.getMessage());
			throw e;
		}
	}

	/* ==== FORCE CLIENT REFRESH ==== */
	private void forceClientRefresh(IContext ctx, IMendixObject... objects) throws Exception {
		List<IMendixObject> refreshList = new ArrayList<>();
		
		for (IMendixObject obj : objects) {
			if (obj != null) {
				refreshList.add(obj);
			}
		}
		
		if (!refreshList.isEmpty()) {
			// Technique 1: Commit normal d'abord
			Core.commit(ctx, refreshList);
			
			// Technique 2: Re-commit pour forcer propagation
			try {
				Thread.sleep(10); // Petite pause pour laisser le temps √† Mendix
				Core.commit(ctx, refreshList);
			} catch (InterruptedException e) {
				Thread.currentThread().interrupt();
			}
			
			// Technique 3: Log pour tra√ßabilit√©
			getLogger().debug("üîÑ Double refresh client forc√© pour " + refreshList.size() + " objet(s)");
		}
	}

	private void forceClientRefresh(IContext ctx, List<IMendixObject> objects) throws Exception {
		if (objects != null && !objects.isEmpty()) {
			// Cr√©er une nouvelle liste pour √©viter les modifications concurrentes
			List<IMendixObject> refreshList = new ArrayList<>(objects);
			
			// Technique 1: Commit normal
			Core.commit(ctx, refreshList);
			
			// Technique 2: Re-commit apr√®s pause pour garantir propagation
			try {
				Thread.sleep(10); // Pause courte
				Core.commit(ctx, refreshList);
			} catch (InterruptedException e) {
				Thread.currentThread().interrupt();
			}
			
			getLogger().debug("üîÑ Double refresh client forc√© pour " + refreshList.size() + " objet(s) via liste");
		}
	}

	/* ==== CLASSE POUR LES STATISTIQUES ==== */
	private static class ProcessingStats {
		int assetsProcessed = 0;
		int assetsCreated = 0;
		int assetsUpdated = 0;
		int assetsSkipped = 0;
		int assetsCommitted = 0;
		int levelsCreated = 0;
		int iihApiCalls = 0;
		int cyclesDetected = 0;
		int maxDepthReached = 0;
		int errors = 0;
	}

	/* ------------- FINALISER LES M√âTADONN√âES DE SYNC ------------- */
	private void finalizeSyncMetadata(SyncMetadata syncMeta, ProcessingStats stats, 
									  long durationMs, Exception error) throws Exception {
		
		IContext ctx = getContext();
		
		syncMeta.setSyncEndTime(new Date());
		syncMeta.setDurationMs((int) durationMs);
		syncMeta.setAssetsProcessed(stats.assetsProcessed);
		syncMeta.setAssetsCreated(stats.assetsCreated);
		syncMeta.setAssetsUpdated(stats.assetsUpdated);
		syncMeta.setLevelsCreated(stats.levelsCreated);
		syncMeta.setIihApiCalls(stats.iihApiCalls);
		syncMeta.setErrorCount(stats.errors);
		
		if (error != null) {
			syncMeta.setSyncStatus(SyncStatus.Error);
			syncMeta.setErrorMessage(error.getMessage());
			getLogger().error("‚ùå Sync termin√©e avec erreur: " + error.getMessage());
		} else {
			syncMeta.setSyncStatus(SyncStatus.Completed);
			getLogger().info("‚úÖ Sync termin√©e avec succ√®s");
		}

		forceClientRefresh(ctx, syncMeta.getMendixObject());
		getLogger().info("üîÑ M√©tadonn√©es de sync finalis√©es avec refresh client forc√©");
	}

	/* ------------- GESTION NIVEAU AVEC CACHE ------------- */
	private IMendixObject getOrCreateLevelCached(IContext ctx, int sortOrder, 
												 Map<Integer, IMendixObject> levelCache, 
												 ProcessingStats stats) throws Exception {
		
		// V√©rifier le cache d'abord
		if (levelCache.containsKey(sortOrder)) {
			return levelCache.get(sortOrder);
		}

		// Chercher en base
		List<IMendixObject> res = Core.retrieveXPathQuery(ctx, "//Smart.Level[SortOrder=" + sortOrder + "]");
		
		IMendixObject level;
		if (!res.isEmpty()) {
			level = res.get(0);
		} else {
			// Cr√©er nouveau niveau
			Level lvl = new Level(ctx);
			lvl.setName("L" + sortOrder);
			lvl.setSortOrder(sortOrder);
			forceClientRefresh(ctx, lvl.getMendixObject());
			level = lvl.getMendixObject();
			stats.levelsCreated++;
			getLogger().debug("üìã Niveau L" + sortOrder + " cr√©√© avec refresh client forc√©");
		}

		// Mettre en cache
		levelCache.put(sortOrder, level);
		return level;
	}

	/* ------------- STATISTIQUES FINALES ------------- */
	private void logFinalStats(ProcessingStats stats, long durationMs) {
		getLogger().info("=== STATISTIQUES FINALES ===");
		getLogger().info("‚è±Ô∏è  Dur√©e: " + durationMs + "ms (" + (durationMs/1000.0) + "s)");
		getLogger().info("üìä Assets trait√©s: " + stats.assetsProcessed);
		getLogger().info("‚ú® Assets cr√©√©s: " + stats.assetsCreated);
		getLogger().info("üîÑ Assets mis √† jour: " + stats.assetsUpdated);
		getLogger().info("‚è≠Ô∏è Assets ignor√©s: " + stats.assetsSkipped);
		getLogger().info("üíæ Assets committ√©s: " + stats.assetsCommitted);
		getLogger().info("üìã Niveaux cr√©√©s: " + stats.levelsCreated);
		getLogger().info("üåê Appels API IIH: " + stats.iihApiCalls);
		getLogger().info("üîÑ Cycles d√©tect√©s: " + stats.cyclesDetected);
		getLogger().info("‚ö†Ô∏è Profondeur max atteinte: " + stats.maxDepthReached);
		getLogger().info("‚ùå Erreurs: " + stats.errors);
		
		if (stats.assetsProcessed > 0) {
			double avgTimePerAsset = (double) durationMs / stats.assetsProcessed;
			getLogger().info("üìà Temps moyen par asset: " + String.format("%.2f", avgTimePerAsset) + "ms");
		}
		
		getLogger().info("=== FIN SYNCHRONISATION ===");
	}

	/* ------------- NETTOYAGE ASSETS & LEVELS ------------- */
	private void cleanupAssetsAndLevels(IContext ctx) throws Exception {
		// Supprimer les variables d'abord pour √©viter contraintes d'int√©grit√©
		List<IMendixObject> variables = Core.retrieveXPathQuery(ctx, "//Smart.Variable");
		if (!variables.isEmpty()) {
			Core.deleteWithoutEvents(ctx, variables, false);
			getLogger().info("üóëÔ∏è  " + variables.size() + " Variables supprim√©es");
		}

		List<IMendixObject> assets = Core.retrieveXPathQuery(ctx, "//Smart.Asset");
		if (!assets.isEmpty()) {
			Core.deleteWithoutEvents(ctx, assets, false);
			getLogger().info("üóëÔ∏è  " + assets.size() + " Assets supprim√©s");
		}

		List<IMendixObject> levels = Core.retrieveXPathQuery(ctx, "//Smart.Level");
		if (!levels.isEmpty()) {
			Core.deleteWithoutEvents(ctx, levels, false);
			getLogger().info("üóëÔ∏è  " + levels.size() + " Levels supprim√©s");
		}
	}

	/**
	 * Calcule le niveau absolu d'un asset √† partir de son parent persist√© (Mendix)
	 */
	private int calculateLevelFromParent(IContext ctx, Asset persistentParent) throws Exception {
		if (persistentParent == null) {
			return 0; // Root = niveau 0
		}
		Level parentLevel = persistentParent.getAsset_Level();
		if (parentLevel != null) {
			return parentLevel.getSortOrder() + 1;
		}
		Asset grandParent = persistentParent.getAsset_Parent();
		return calculateLevelFromParent(ctx, grandParent) + 1;
	}

	/**
	 * Supprime l'asset root (IIH_Id = "0") apr√®s la synchronisation
	 */
	private void cleanupRootAsset(IContext ctx) throws Exception {
		List<IMendixObject> rootAssets = Core.retrieveXPathQuery(ctx, "//Smart.Asset[IIH_Id='0']");
		if (!rootAssets.isEmpty()) {
			// D'abord, r√©assigner les enfants du root pour qu'ils n'aient plus de parent
			for (IMendixObject rootObj : rootAssets) {
				Asset root = Asset.initialize(ctx, rootObj);
				List<IMendixObject> children = Core.retrieveXPathQuery(ctx, 
					"//Smart.Asset[Smart.Asset_Parent=" + root.getMendixObject().getId().toLong() + "]");
				for (IMendixObject childObj : children) {
					Asset child = Asset.initialize(ctx, childObj);
					child.setAsset_Parent(null);
					Core.commit(ctx, child.getMendixObject());
				}
			}
			Core.deleteWithoutEvents(ctx, rootAssets, false);
			getLogger().info("üóëÔ∏è Asset root (IIH_Id='0') supprim√© apr√®s synchronisation");
		}
	}
	// END EXTRA CODE
}
